<!DOCTYPE html>
<html lang="en" class="Internet-Draft">
<head>
<meta charset="utf-8">
<meta content="Common,Latin" name="scripts">
<meta content="initial-scale=1.0" name="viewport">
<title>Sockets API Extensions for In-kernel QUIC Implementations</title>
<meta content="Xin Long" name="author">
<meta content="
       This document describes a mapping of In-kernel QUIC Implementations
into a sockets API.  The benefits of this mapping include compatibility
for TCP applications, access to new QUIC features, and a consolidated
error and event notification scheme. In-kernel QUIC enables usage for
both userspace applications and kernel consumers. 
    " name="description">
<meta content="xml2rfc 3.22.0" name="generator">
<meta content="QUIC socket APIs" name="keyword">
<meta content="draft-lxin-quic-socket-apis-00" name="ietf.draft">
<!-- Generator version information:
  xml2rfc 3.22.0
    Python 3.9.19
    ConfigArgParse 1.7
    google-i18n-address 3.1.0
    intervaltree 3.1.0
    Jinja2 3.1.4
    lxml 4.9.4
    platformdirs 4.2.2
    pycountry 24.6.1
    PyYAML 5.4.1
    requests 2.25.1
    setuptools 53.0.0
    wcwidth 0.2.13
-->
<link href="./draft-lxin-quic-socket-apis.xml" rel="alternate" type="application/rfc+xml">
<link href="#copyright" rel="license">
<style type="text/css">/*

  NOTE: Changes at the bottom of this file overrides some earlier settings.

  Once the style has stabilized and has been adopted as an official RFC style,
  this can be consolidated so that style settings occur only in one place, but
  for now the contents of this file consists first of the initial CSS work as
  provided to the RFC Formatter (xml2rfc) work, followed by itemized and
  commented changes found necessary during the development of the v3
  formatters.

*/

/* fonts */
@import url('https://fonts.googleapis.com/css?family=Noto+Sans'); /* Sans-serif */
@import url('https://fonts.googleapis.com/css?family=Noto+Serif'); /* Serif (print) */
@import url('https://fonts.googleapis.com/css?family=Roboto+Mono'); /* Monospace */

:root {
  --font-sans: 'Noto Sans', Arial, Helvetica, sans-serif;
  --font-serif: 'Noto Serif', 'Times', 'Times New Roman', serif;
  --font-mono: 'Roboto Mono', Courier, 'Courier New', monospace;
}

@viewport {
  zoom: 1.0;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}
/* general and mobile first */
html {
}
body {
  max-width: 90%;
  margin: 1.5em auto;
  color: #222;
  background-color: #fff;
  font-size: 14px;
  font-family: var(--font-sans);
  line-height: 1.6;
  scroll-behavior: smooth;
  overflow-wrap: break-word;
}
.ears {
  display: none;
}

/* headings */
#title, h1, h2, h3, h4, h5, h6 {
  margin: 1em 0 0.5em;
  font-weight: bold;
  line-height: 1.3;
}
#title {
  clear: both;
  border-bottom: 1px solid #ddd;
  margin: 0 0 0.5em 0;
  padding: 1em 0 0.5em;
}
.author {
  padding-bottom: 4px;
}
h1 {
  font-size: 26px;
  margin: 1em 0;
}
h2 {
  font-size: 22px;
  margin-top: -20px;  /* provide offset for in-page anchors */
  padding-top: 33px;
}
h3 {
  font-size: 18px;
  margin-top: -36px;  /* provide offset for in-page anchors */
  padding-top: 42px;
}
h4 {
  font-size: 16px;
  margin-top: -36px;  /* provide offset for in-page anchors */
  padding-top: 42px;
}
h5, h6 {
  font-size: 14px;
}
#n-copyright-notice {
  border-bottom: 1px solid #ddd;
  padding-bottom: 1em;
  margin-bottom: 1em;
}
/* general structure */
p {
  padding: 0;
  margin: 0 0 1em 0;
  text-align: left;
}
div, span {
  position: relative;
}
div {
  margin: 0;
}
.alignRight.art-text {
  background-color: #f9f9f9;
  border: 1px solid #eee;
  border-radius: 3px;
  padding: 1em 1em 0;
  margin-bottom: 1.5em;
}
.alignRight.art-text pre {
  padding: 0;
}
.alignRight {
  margin: 1em 0;
}
.alignRight > *:first-child {
  border: none;
  margin: 0;
  float: right;
  clear: both;
}
.alignRight > *:nth-child(2) {
  clear: both;
  display: block;
  border: none;
}
svg {
  display: block;
}
svg[font-family~="serif" i], svg [font-family~="serif" i] {
  font-family: var(--font-serif);
}
svg[font-family~="sans-serif" i], svg [font-family~="sans-serif" i] {
  font-family: var(--font-sans);
}
svg[font-family~="monospace" i], svg [font-family~="monospace" i] {
  font-family: var(--font-mono);
}
.alignCenter.art-text {
  background-color: #f9f9f9;
  border: 1px solid #eee;
  border-radius: 3px;
  padding: 1em 1em 0;
  margin-bottom: 1.5em;
}
.alignCenter.art-text pre {
  padding: 0;
}
.alignCenter {
  margin: 1em 0;
}
.alignCenter > *:first-child {
  display: table;
  border: none;
  margin: 0 auto;
}

/* lists */
ol, ul {
  padding: 0;
  margin: 0 0 1em 2em;
}
ol ol, ul ul, ol ul, ul ol {
  margin-left: 1em;
}
li {
  margin: 0 0 0.25em 0;
}
.ulCompact li {
  margin: 0;
}
ul.empty, .ulEmpty {
  list-style-type: none;
}
ul.empty li, .ulEmpty li {
  margin-top: 0.5em;
}
ul.ulBare, li.ulBare {
  margin-left: 0em !important;
}
ul.compact, .ulCompact,
ol.compact, .olCompact {
  line-height: 100%;
  margin: 0 0 0 2em;
}

/* definition lists */
dl {
}
dl > dt {
  float: left;
  margin-right: 1em;
}
/* 
dl.nohang > dt {
  float: none;
}
*/
dl > dd {
  margin-bottom: .8em;
  min-height: 1.3em;
}
dl.compact > dd, .dlCompact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}

/* links */
a {
  text-decoration: none;
}
a[href] {
  color: #22e; /* Arlen: WCAG 2019 */
}
a[href]:hover {
  background-color: #f2f2f2;
}
figcaption a[href],
a[href].selfRef {
  color: #222;
}
/* XXX probably not this:
a.selfRef:hover {
  background-color: transparent;
  cursor: default;
} */

/* Figures */
tt, code, pre {
  background-color: #f9f9f9;
  font-family: var(--font-mono);
}
pre {
  border: 1px solid #eee;
  margin: 0;
  padding: 1em;
}
img {
  max-width: 100%;
}
figure {
  margin: 0;
}
figure blockquote {
  margin: 0.8em 0.4em 0.4em;
}
figcaption {
  font-style: italic;
  margin: 0 0 1em 0;
}
@media screen {
  pre {
    overflow-x: auto;
    max-width: 100%;
    max-width: calc(100% - 22px);
  }
}

/* aside, blockquote */
aside, blockquote {
  margin-left: 0;
  padding: 1.2em 2em;
}
blockquote {
  background-color: #f9f9f9;
  color: #111; /* Arlen: WCAG 2019 */
  border: 1px solid #ddd;
  border-radius: 3px;
  margin: 1em 0;
}
blockquote > *:last-child {
  margin-bottom: 0;
}
cite {
  display: block;
  text-align: right;
  font-style: italic;
}
.xref {
  overflow-wrap: normal;
}

/* tables */
table {
  width: 100%;
  margin: 0 0 1em;
  border-collapse: collapse;
  border: 1px solid #eee;
}
th, td {
  text-align: left;
  vertical-align: top;
  padding: 0.5em 0.75em;
}
th {
  text-align: left;
  background-color: #e9e9e9;
}
tr:nth-child(2n+1) > td {
  background-color: #f5f5f5;
}
table caption {
  font-style: italic;
  margin: 0;
  padding: 0;
  text-align: left;
}
table p {
  /* XXX to avoid bottom margin on table row signifiers. If paragraphs should
     be allowed within tables more generally, it would be far better to select on a class. */
  margin: 0;
}

/* pilcrow */
a.pilcrow {
  color: #666; /* Arlen: AHDJ 2019 */
  text-decoration: none;
  visibility: hidden;
  user-select: none;
  -ms-user-select: none;
  -o-user-select:none;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -webkit-touch-callout: none;
}
@media screen {
  aside:hover > a.pilcrow,
  p:hover > a.pilcrow,
  blockquote:hover > a.pilcrow,
  div:hover > a.pilcrow,
  li:hover > a.pilcrow,
  pre:hover > a.pilcrow {
    visibility: visible;
  }
  a.pilcrow:hover {
    background-color: transparent;
  }
}

/* misc */
hr {
  border: 0;
  border-top: 1px solid #eee;
}
.bcp14 {
  font-variant: small-caps;
}

.role {
  font-variant: all-small-caps;
}

/* info block */
#identifiers {
  margin: 0;
  font-size: 0.9em;
}
#identifiers dt {
  width: 3em;
  clear: left;
}
#identifiers dd {
  float: left;
  margin-bottom: 0;
}
/* Fix PDF info block run off issue */
@media print {
  #identifiers dd {
    float: none;
  }
}
#identifiers .authors .author {
  display: inline-block;
  margin-right: 1.5em;
}
#identifiers .authors .org {
  font-style: italic;
}

/* The prepared/rendered info at the very bottom of the page */
.docInfo {
  color: #666; /* Arlen: WCAG 2019 */
  font-size: 0.9em;
  font-style: italic;
  margin-top: 2em;
}
.docInfo .prepared {
  float: left;
}
.docInfo .prepared {
  float: right;
}

/* table of contents */
#toc  {
  padding: 0.75em 0 2em 0;
  margin-bottom: 1em;
}
nav.toc ul {
  margin: 0 0.5em 0 0;
  padding: 0;
  list-style: none;
}
nav.toc li {
  line-height: 1.3em;
  margin: 0.75em 0;
  padding-left: 1.2em;
  text-indent: -1.2em;
}
/* references */
.references dt {
  text-align: right;
  font-weight: bold;
  min-width: 7em;
}
.references dd {
  margin-left: 8em;
  overflow: auto;
}

.refInstance {
  margin-bottom: 1.25em;
}

.refSubseries {
  margin-bottom: 1.25em;
}

.references .ascii {
  margin-bottom: 0.25em;
}

/* index */
.index ul {
  margin: 0 0 0 1em;
  padding: 0;
  list-style: none;
}
.index ul ul {
  margin: 0;
}
.index li {
  margin: 0;
  text-indent: -2em;
  padding-left: 2em;
  padding-bottom: 5px;
}
.indexIndex {
  margin: 0.5em 0 1em;
}
.index a {
  font-weight: 700;
}
/* make the index two-column on all but the smallest screens */
@media (min-width: 600px) {
  .index ul {
    -moz-column-count: 2;
    -moz-column-gap: 20px;
  }
  .index ul ul {
    -moz-column-count: 1;
    -moz-column-gap: 0;
  }
}

/* authors */
address.vcard {
  font-style: normal;
  margin: 1em 0;
}

address.vcard .nameRole {
  font-weight: 700;
  margin-left: 0;
}
address.vcard .label {
  font-family: var(--font-sans);
  margin: 0.5em 0;
}
address.vcard .type {
  display: none;
}
.alternative-contact {
  margin: 1.5em 0 1em;
}
hr.addr {
  border-top: 1px dashed;
  margin: 0;
  color: #ddd;
  max-width: calc(100% - 16px);
}

/* temporary notes */
.rfcEditorRemove::before {
  position: absolute;
  top: 0.2em;
  right: 0.2em;
  padding: 0.2em;
  content: "The RFC Editor will remove this note";
  color: #9e2a00; /* Arlen: WCAG 2019 */
  background-color: #ffd; /* Arlen: WCAG 2019 */
}
.rfcEditorRemove {
  position: relative;
  padding-top: 1.8em;
  background-color: #ffd; /* Arlen: WCAG 2019 */
  border-radius: 3px;
}
.cref {
  background-color: #ffd; /* Arlen: WCAG 2019 */
  padding: 2px 4px;
}
.crefSource {
  font-style: italic;
}
/* alternative layout for smaller screens */
@media screen and (max-width: 1023px) {
  body {
    padding-top: 2em;
  }
  #title {
    padding: 1em 0;
  }
  h1 {
    font-size: 24px;
  }
  h2 {
    font-size: 20px;
    margin-top: -18px;  /* provide offset for in-page anchors */
    padding-top: 38px;
  }
  #identifiers dd {
    max-width: 60%;
  }
  #toc {
    position: fixed;
    z-index: 2;
    top: 0;
    right: 0;
    padding: 0;
    margin: 0;
    background-color: inherit;
    border-bottom: 1px solid #ccc;
  }
  #toc h2 {
    margin: -1px 0 0 0;
    padding: 4px 0 4px 6px;
    padding-right: 1em;
    min-width: 190px;
    font-size: 1.1em;
    text-align: right;
    background-color: #444;
    color: white;
    cursor: pointer;
  }
  #toc h2::before { /* css hamburger */
    float: right;
    position: relative;
    width: 1em;
    height: 1px;
    left: -164px;
    margin: 6px 0 0 0;
    background: white none repeat scroll 0 0;
    box-shadow: 0 4px 0 0 white, 0 8px 0 0 white;
    content: "";
  }
  #toc nav {
    display: none;
    padding: 0.5em 1em 1em;
    overflow: auto;
    height: calc(100vh - 48px);
    border-left: 1px solid #ddd;
  }
}

/* alternative layout for wide screens */
@media screen and (min-width: 1024px) {
  body {
    max-width: 724px;
    margin: 42px auto;
    padding-left: 1.5em;
    padding-right: 29em;
  }
  #toc {
    position: fixed;
    top: 42px;
    right: 42px;
    width: 25%;
    margin: 0;
    padding: 0 1em;
    z-index: 1;
  }
  #toc h2 {
    border-top: none;
    border-bottom: 1px solid #ddd;
    font-size: 1em;
    font-weight: normal;
    margin: 0;
    padding: 0.25em 1em 1em 0;
  }
  #toc nav {
    display: block;
    height: calc(90vh - 84px);
    bottom: 0;
    padding: 0.5em 0 0;
    overflow: auto;
  }
  img { /* future proofing */
    max-width: 100%;
    height: auto;
  }
}

/* pagination */
@media print {
  body {
    width: 100%;
  }
  p {
    orphans: 3;
    widows: 3;
  }
  #n-copyright-notice {
    border-bottom: none;
  }
  #toc, #n-introduction {
    page-break-before: always;
  }
  #toc {
    border-top: none;
    padding-top: 0;
  }
  figure, pre {
    page-break-inside: avoid;
  }
  figure {
    overflow: scroll;
  }
  .breakable pre {
    break-inside: auto;
  }
  h1, h2, h3, h4, h5, h6 {
    page-break-after: avoid;
  }
  h2+*, h3+*, h4+*, h5+*, h6+* {
    page-break-before: avoid;
  }
  pre {
    white-space: pre-wrap;
    word-wrap: break-word;
    font-size: 10pt;
  }
  table {
    border: 1px solid #ddd;
  }
  td {
    border-top: 1px solid #ddd;
  }
}

/* This is commented out here, as the string-set: doesn't
   pass W3C validation currently */
/*
.ears thead .left {
  string-set: ears-top-left content();
}

.ears thead .center {
  string-set: ears-top-center content();
}

.ears thead .right {
  string-set: ears-top-right content();
}

.ears tfoot .left {
  string-set: ears-bottom-left content();
}

.ears tfoot .center {
  string-set: ears-bottom-center content();
}

.ears tfoot .right {
  string-set: ears-bottom-right content();
}
*/

@page :first {
  padding-top: 0;
  @top-left {
    content: normal;
    border: none;
  }
  @top-center {
    content: normal;
    border: none;
  }
  @top-right {
    content: normal;
    border: none;
  }
}

@page {
  size: A4;
  margin-bottom: 45mm;
  padding-top: 20px;
  /* The following is commented out here, but set appropriately by in code, as
     the content depends on the document */
  /*
  @top-left {
    content: 'Internet-Draft';
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @top-left {
    content: string(ears-top-left);
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @top-center {
    content: string(ears-top-center);
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @top-right {
    content: string(ears-top-right);
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @bottom-left {
    content: string(ears-bottom-left);
    vertical-align: top;
    border-top: solid 1px #ccc;
  }
  @bottom-center {
    content: string(ears-bottom-center);
    vertical-align: top;
    border-top: solid 1px #ccc;
  }
  @bottom-right {
      content: '[Page ' counter(page) ']';
      vertical-align: top;
      border-top: solid 1px #ccc;
  }
  */

}

/* Changes introduced to fix issues found during implementation */
/* Make sure links are clickable even if overlapped by following H* */
a {
  z-index: 2;
}
/* Separate body from document info even without intervening H1 */
section {
  clear: both;
}


/* Top align author divs, to avoid names without organization dropping level with org names */
.author {
  vertical-align: top;
}

/* Leave room in document info to show Internet-Draft on one line */
#identifiers dt {
  width: 8em;
}

/* Don't waste quite as much whitespace between label and value in doc info */
#identifiers dd {
  margin-left: 1em;
}

/* Give floating toc a background color (needed when it's a div inside section */
#toc {
  background-color: white;
}

/* Make the collapsed ToC header render white on gray also when it's a link */
@media screen and (max-width: 1023px) {
  #toc h2 a,
  #toc h2 a:link,
  #toc h2 a:focus,
  #toc h2 a:hover,
  #toc a.toplink,
  #toc a.toplink:hover {
    color: white;
    background-color: #444;
    text-decoration: none;
  }
}

/* Give the bottom of the ToC some whitespace */
@media screen and (min-width: 1024px) {
  #toc {
    padding: 0 0 1em 1em;
  }
}

/* Style section numbers with more space between number and title */
.section-number {
  padding-right: 0.5em;
}

/* prevent monospace from becoming overly large */
tt, code, pre {
  font-size: 95%;
}

/* Fix the height/width aspect for ascii art*/
.sourcecode pre,
.art-text pre {
  line-height: 1.12;
}


/* Add styling for a link in the ToC that points to the top of the document */
a.toplink {
  float: right;
  margin-right: 0.5em;
}

/* Fix the dl styling to match the RFC 7992 attributes */
dl > dt,
dl.dlParallel > dt {
  float: left;
  margin-right: 1em;
}
dl.dlNewline > dt {
  float: none;
}

/* Provide styling for table cell text alignment */
table td.text-left,
table th.text-left {
  text-align: left;
}
table td.text-center,
table th.text-center {
  text-align: center;
}
table td.text-right,
table th.text-right {
  text-align: right;
}

/* Make the alternative author contact information look less like just another
   author, and group it closer with the primary author contact information */
.alternative-contact {
  margin: 0.5em 0 0.25em 0;
}
address .non-ascii {
  margin: 0 0 0 2em;
}

/* With it being possible to set tables with alignment
  left, center, and right, { width: 100%; } does not make sense */
table {
  width: auto;
}

/* Avoid reference text that sits in a block with very wide left margin,
   because of a long floating dt label.*/
.references dd {
  overflow: visible;
}

/* Control caption placement */
caption {
  caption-side: bottom;
}

/* Limit the width of the author address vcard, so names in right-to-left
   script don't end up on the other side of the page. */

address.vcard {
  max-width: 30em;
  margin-right: auto;
}

/* For address alignment dependent on LTR or RTL scripts */
address div.left {
  text-align: left;
}
address div.right {
  text-align: right;
}

/* Provide table alignment support.  We can't use the alignX classes above
   since they do unwanted things with caption and other styling. */
table.right {
 margin-left: auto;
 margin-right: 0;
}
table.center {
 margin-left: auto;
 margin-right: auto;
}
table.left {
 margin-left: 0;
 margin-right: auto;
}

/* Give the table caption label the same styling as the figcaption */
caption a[href] {
  color: #222;
}

@media print {
  .toplink {
    display: none;
  }

  /* avoid overwriting the top border line with the ToC header */
  #toc {
    padding-top: 1px;
  }

  /* Avoid page breaks inside dl and author address entries */
  .vcard {
    page-break-inside: avoid;
  }

}
/* Tweak the bcp14 keyword presentation */
.bcp14 {
  font-variant: small-caps;
  font-weight: bold;
  font-size: 0.9em;
}
/* Tweak the invisible space above H* in order not to overlay links in text above */
 h2 {
  margin-top: -18px;  /* provide offset for in-page anchors */
  padding-top: 31px;
 }
 h3 {
  margin-top: -18px;  /* provide offset for in-page anchors */
  padding-top: 24px;
 }
 h4 {
  margin-top: -18px;  /* provide offset for in-page anchors */
  padding-top: 24px;
 }
/* Float artwork pilcrow to the right */
@media screen {
  .artwork a.pilcrow {
    display: block;
    line-height: 0.7;
    margin-top: 0.15em;
  }
}
/* Make pilcrows on dd visible */
@media screen {
  dd:hover > a.pilcrow {
    visibility: visible;
  }
}
/* Make the placement of figcaption match that of a table's caption
   by removing the figure's added bottom margin */
.alignLeft.art-text,
.alignCenter.art-text,
.alignRight.art-text {
   margin-bottom: 0;
}
.alignLeft,
.alignCenter,
.alignRight {
  margin: 1em 0 0 0;
}
/* In print, the pilcrow won't show on hover, so prevent it from taking up space,
   possibly even requiring a new line */
@media print {
  a.pilcrow {
    display: none;
  }
}
/* Styling for the external metadata */
div#external-metadata {
  background-color: #eee;
  padding: 0.5em;
  margin-bottom: 0.5em;
  display: none;
}
div#internal-metadata {
  padding: 0.5em;                       /* to match the external-metadata padding */
}
/* Styling for title RFC Number */
h1#rfcnum {
  clear: both;
  margin: 0 0 -1em;
  padding: 1em 0 0 0;
}
/* Make .olPercent look the same as <ol><li> */
dl.olPercent > dd {
  margin-bottom: 0.25em;
  min-height: initial;
}
/* Give aside some styling to set it apart */
aside {
  border-left: 1px solid #ddd;
  margin: 1em 0 1em 2em;
  padding: 0.2em 2em;
}
aside > dl,
aside > ol,
aside > ul,
aside > table,
aside > p {
  margin-bottom: 0.5em;
}
/* Additional page break settings */
@media print {
  figcaption, table caption {
    page-break-before: avoid;
  }
}
/* Font size adjustments for print */
@media print {
  body  { font-size: 10pt;      line-height: normal; max-width: 96%; }
  h1    { font-size: 1.72em;    padding-top: 1.5em; } /* 1*1.2*1.2*1.2 */
  h2    { font-size: 1.44em;    padding-top: 1.5em; } /* 1*1.2*1.2 */
  h3    { font-size: 1.2em;     padding-top: 1.5em; } /* 1*1.2 */
  h4    { font-size: 1em;       padding-top: 1.5em; }
  h5, h6 { font-size: 1em;      margin: initial; padding: 0.5em 0 0.3em; }
}
/* Sourcecode margin in print, when there's no pilcrow */
@media print {
  .artwork,
  .artwork > pre,
  .sourcecode {
    margin-bottom: 1em;
  }
}
/* Avoid narrow tables forcing too narrow table captions, which may render badly */
table {
  min-width: 20em;
}
/* ol type a */
ol.type-a { list-style-type: lower-alpha; }
ol.type-A { list-style-type: upper-alpha; }
ol.type-i { list-style-type: lower-roman; }
ol.type-I { list-style-type: upper-roman; }
/* Apply the print table and row borders in general, on request from the RPC,
and increase the contrast between border and odd row background slightly */
table {
  border: 1px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
}
tr {
  break-inside: avoid;
}
tr:nth-child(2n+1) > td {
  background-color: #f8f8f8;
}
/* Use style rules to govern display of the TOC. */
@media screen and (max-width: 1023px) {
  #toc nav { display: none; }
  #toc.active nav { display: block; }
}
/* Add support for keepWithNext */
.keepWithNext {
  break-after: avoid-page;
  break-after: avoid-page;
}
/* Add support for keepWithPrevious */
.keepWithPrevious {
  break-before: avoid-page;
}
/* Change the approach to avoiding breaks inside artwork etc. */
figure, pre, table, .artwork, .sourcecode  {
  break-before: auto;
  break-after: auto;
}
/* Avoid breaks between <dt> and <dd> */
dl {
  break-before: auto;
  break-inside: auto;
}
dt {
  break-before: auto;
  break-after: avoid-page;
}
dd {
  break-before: avoid-page;
  break-after: auto;
  orphans: 3;
  widows: 3
}
span.break, dd.break {
  margin-bottom: 0;
  min-height: 0;
  break-before: auto;
  break-inside: auto;
  break-after: auto;
}
/* Undo break-before ToC */
@media print {
  #toc {
    break-before: auto;
  }
}
/* Text in compact lists should not get extra bottom margin space,
   since that would makes the list not compact */
ul.compact p, .ulCompact p,
ol.compact p, .olCompact p {
 margin: 0;
}
/* But the list as a whole needs the extra space at the end */
section ul.compact,
section .ulCompact,
section ol.compact,
section .olCompact {
  margin-bottom: 1em;                    /* same as p not within ul.compact etc. */
}
/* The tt and code background above interferes with for instance table cell
   backgrounds.  Changed to something a bit more selective. */
tt, code {
  background-color: transparent;
}
p tt, p code, li tt, li code {
  background-color: #f8f8f8;
}
/* Tweak the pre margin -- 0px doesn't come out well */
pre {
   margin-top: 0.5px;
}
/* Tweak the compact list text */
ul.compact, .ulCompact,
ol.compact, .olCompact,
dl.compact, .dlCompact {
  line-height: normal;
}
/* Don't add top margin for nested lists */
li > ul, li > ol, li > dl,
dd > ul, dd > ol, dd > dl,
dl > dd > dl {
  margin-top: initial;
}
/* Elements that should not be rendered on the same line as a <dt> */
/* This should match the element list in writer.text.TextWriter.render_dl() */
dd > div.artwork:first-child,
dd > aside:first-child,
dd > figure:first-child,
dd > ol:first-child,
dd > div.sourcecode:first-child,
dd > table:first-child,
dd > ul:first-child {
  clear: left;
}
/* fix for weird browser behaviour when <dd/> is empty */
dt+dd:empty::before{
  content: "\00a0";
}
/* Make paragraph spacing inside <li> smaller than in body text, to fit better within the list */
li > p {
  margin-bottom: 0.5em
}
/* Don't let p margin spill out from inside list items */
li > p:last-of-type:only-child {
  margin-bottom: 0;
}
</style>
<link href="rfc-local.css" rel="stylesheet" type="text/css">
</head>
<body class="xml2rfc">
<script src="metadata.min.js"></script>
<table class="ears">
<thead><tr>
<td class="left">Internet-Draft</td>
<td class="center">QUIC socket APIs</td>
<td class="right">August 2024</td>
</tr></thead>
<tfoot><tr>
<td class="left">Xin</td>
<td class="center">Expires 20 February 2025</td>
<td class="right">[Page]</td>
</tr></tfoot>
</table>
<div id="external-metadata" class="document-information"></div>
<div id="internal-metadata" class="document-information">
<dl id="identifiers">
<dt class="label-workgroup">Workgroup:</dt>
<dd class="workgroup">Internet Engineering Task Force</dd>
<dt class="label-internet-draft">Internet-Draft:</dt>
<dd class="internet-draft">draft-lxin-quic-socket-apis-00</dd>
<dt class="label-published">Published:</dt>
<dd class="published">
<time datetime="2024-08-19" class="published">19 August 2024</time>
    </dd>
<dt class="label-intended-status">Intended Status:</dt>
<dd class="intended-status">Standards Track</dd>
<dt class="label-expires">Expires:</dt>
<dd class="expires"><time datetime="2025-02-20">20 February 2025</time></dd>
<dt class="label-authors">Author:</dt>
<dd class="authors">
<div class="author">
      <div class="author-name">L. Xin, <span class="editor">Ed.</span>
</div>
<div class="org">Red Hat</div>
</div>
</dd>
</dl>
</div>
<h1 id="title">Sockets API Extensions for In-kernel QUIC Implementations</h1>
<section id="section-abstract">
      <h2 id="abstract"><a href="#abstract" class="selfRef">Abstract</a></h2>
<p id="section-abstract-1">This document describes a mapping of In-kernel QUIC Implementations
into a sockets API.  The benefits of this mapping include compatibility
for TCP applications, access to new QUIC features, and a consolidated
error and event notification scheme. In-kernel QUIC enables usage for
both userspace applications and kernel consumers.<a href="#section-abstract-1" class="pilcrow">¶</a></p>
</section>
<div id="status-of-memo">
<section id="section-boilerplate.1">
        <h2 id="name-status-of-this-memo">
<a href="#name-status-of-this-memo" class="section-name selfRef">Status of This Memo</a>
        </h2>
<p id="section-boilerplate.1-1">
        This Internet-Draft is submitted in full conformance with the
        provisions of BCP 78 and BCP 79.<a href="#section-boilerplate.1-1" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-2">
        Internet-Drafts are working documents of the Internet Engineering Task
        Force (IETF). Note that other groups may also distribute working
        documents as Internet-Drafts. The list of current Internet-Drafts is
        at <span><a href="https://datatracker.ietf.org/drafts/current/">https://datatracker.ietf.org/drafts/current/</a></span>.<a href="#section-boilerplate.1-2" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-3">
        Internet-Drafts are draft documents valid for a maximum of six months
        and may be updated, replaced, or obsoleted by other documents at any
        time. It is inappropriate to use Internet-Drafts as reference
        material or to cite them other than as "work in progress."<a href="#section-boilerplate.1-3" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-4">
        This Internet-Draft will expire on 20 February 2025.<a href="#section-boilerplate.1-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="copyright">
<section id="section-boilerplate.2">
        <h2 id="name-copyright-notice">
<a href="#name-copyright-notice" class="section-name selfRef">Copyright Notice</a>
        </h2>
<p id="section-boilerplate.2-1">
            Copyright (c) 2024 IETF Trust and the persons identified as the
            document authors. All rights reserved.<a href="#section-boilerplate.2-1" class="pilcrow">¶</a></p>
<p id="section-boilerplate.2-2">
            This document is subject to BCP 78 and the IETF Trust's Legal
            Provisions Relating to IETF Documents
            (<span><a href="https://trustee.ietf.org/license-info">https://trustee.ietf.org/license-info</a></span>) in effect on the date of
            publication of this document. Please review these documents
            carefully, as they describe your rights and restrictions with
            respect to this document. Code Components extracted from this
            document must include Revised BSD License text as described in
            Section 4.e of the Trust Legal Provisions and are provided without
            warranty as described in the Revised BSD License.<a href="#section-boilerplate.2-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="toc">
<section id="section-toc.1">
        <a href="#" onclick="scroll(0,0)" class="toplink">▲</a><h2 id="name-table-of-contents">
<a href="#name-table-of-contents" class="section-name selfRef">Table of Contents</a>
        </h2>
<nav class="toc"><ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.1">
            <p id="section-toc.1-1.1.1" class="keepWithNext"><a href="#section-1" class="auto internal xref">1</a>.  <a href="#name-introduction" class="internal xref">Introduction</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.1.2.1">
                <p id="section-toc.1-1.1.2.1.1" class="keepWithNext"><a href="#section-1.1" class="auto internal xref">1.1</a>.  <a href="#name-conventions" class="internal xref">Conventions</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2">
            <p id="section-toc.1-1.2.1" class="keepWithNext"><a href="#section-2" class="auto internal xref">2</a>.  <a href="#name-data-types" class="internal xref">Data Types</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3">
            <p id="section-toc.1-1.3.1"><a href="#section-3" class="auto internal xref">3</a>.  <a href="#name-interface" class="internal xref">Interface</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.1">
                <p id="section-toc.1-1.3.2.1.1"><a href="#section-3.1" class="auto internal xref">3.1</a>.  <a href="#name-basic-operation" class="internal xref">Basic Operation</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.1.2.1">
                    <p id="section-toc.1-1.3.2.1.2.1.1"><a href="#section-3.1.1" class="auto internal xref">3.1.1</a>.  <a href="#name-socket" class="internal xref">socket()</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.1.2.2">
                    <p id="section-toc.1-1.3.2.1.2.2.1"><a href="#section-3.1.2" class="auto internal xref">3.1.2</a>.  <a href="#name-bind" class="internal xref">bind()</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.1.2.3">
                    <p id="section-toc.1-1.3.2.1.2.3.1"><a href="#section-3.1.3" class="auto internal xref">3.1.3</a>.  <a href="#name-listen" class="internal xref">listen()</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.1.2.4">
                    <p id="section-toc.1-1.3.2.1.2.4.1"><a href="#section-3.1.4" class="auto internal xref">3.1.4</a>.  <a href="#name-accept" class="internal xref">accept()</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.1.2.5">
                    <p id="section-toc.1-1.3.2.1.2.5.1"><a href="#section-3.1.5" class="auto internal xref">3.1.5</a>.  <a href="#name-connect" class="internal xref">connect()</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.1.2.6">
                    <p id="section-toc.1-1.3.2.1.2.6.1"><a href="#section-3.1.6" class="auto internal xref">3.1.6</a>.  <a href="#name-close" class="internal xref">close()</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.1.2.7">
                    <p id="section-toc.1-1.3.2.1.2.7.1"><a href="#section-3.1.7" class="auto internal xref">3.1.7</a>.  <a href="#name-shutdown" class="internal xref">shutdown()</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.1.2.8">
                    <p id="section-toc.1-1.3.2.1.2.8.1"><a href="#section-3.1.8" class="auto internal xref">3.1.8</a>.  <a href="#name-sendmsg-and-recvmsg" class="internal xref">sendmsg() and recvmsg()</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.1.2.9">
                    <p id="section-toc.1-1.3.2.1.2.9.1"><a href="#section-3.1.9" class="auto internal xref">3.1.9</a>.  <a href="#name-send-recv-read-and-write" class="internal xref">send(), recv(), read() and write()</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.1.2.10">
                    <p id="section-toc.1-1.3.2.1.2.10.1"><a href="#section-3.1.10" class="auto internal xref">3.1.10</a>. <a href="#name-setsockopt-and-getsockopt" class="internal xref">setsockopt() and getsockopt()</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.1.2.11">
                    <p id="section-toc.1-1.3.2.1.2.11.1"><a href="#section-3.1.11" class="auto internal xref">3.1.11</a>. <a href="#name-getsockname-and-getpeername" class="internal xref">getsockname() and getpeername()</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.2">
                <p id="section-toc.1-1.3.2.2.1"><a href="#section-3.2" class="auto internal xref">3.2</a>.  <a href="#name-advanced-operation" class="internal xref">Advanced Operation</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.2.2.1">
                    <p id="section-toc.1-1.3.2.2.2.1.1"><a href="#section-3.2.1" class="auto internal xref">3.2.1</a>.  <a href="#name-quic_sendmsg-and-quic_recvm" class="internal xref">quic_sendmsg() and quic_recvmsg()</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.2.2.2">
                    <p id="section-toc.1-1.3.2.2.2.2.1"><a href="#section-3.2.2" class="auto internal xref">3.2.2</a>.  <a href="#name-quic_client_handshake-and-q" class="internal xref">quic_client_handshake() and quic_server_handshake()</a></p>
</li>
                </ul>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4">
            <p id="section-toc.1-1.4.1"><a href="#section-4" class="auto internal xref">4</a>.  <a href="#name-data-structures" class="internal xref">Data Structures</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.1">
                <p id="section-toc.1-1.4.2.1.1"><a href="#section-4.1" class="auto internal xref">4.1</a>.  <a href="#name-the-msghdr-and-cmsghdr-stru" class="internal xref">The msghdr and cmsghdr Structures</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.2">
                <p id="section-toc.1-1.4.2.2.1"><a href="#section-4.2" class="auto internal xref">4.2</a>.  <a href="#name-ancillary-data-consideratio" class="internal xref">Ancillary Data Considerations and Semantics</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.2.2.1">
                    <p id="section-toc.1-1.4.2.2.2.1.1"><a href="#section-4.2.1" class="auto internal xref">4.2.1</a>.  <a href="#name-multiple-items-and-ordering" class="internal xref">Multiple Items and Ordering</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.2.2.2">
                    <p id="section-toc.1-1.4.2.2.2.2.1"><a href="#section-4.2.2" class="auto internal xref">4.2.2</a>.  <a href="#name-accessing-and-manipulating-" class="internal xref">Accessing and Manipulating Ancillary Data</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.2.2.3">
                    <p id="section-toc.1-1.4.2.2.2.3.1"><a href="#section-4.2.3" class="auto internal xref">4.2.3</a>.  <a href="#name-control-message-buffer-sizi" class="internal xref">Control Message Buffer Sizing</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.3">
                <p id="section-toc.1-1.4.2.3.1"><a href="#section-4.3" class="auto internal xref">4.3</a>.  <a href="#name-quic-msg_control-structures" class="internal xref">QUIC msg_control Structures</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.3.2.1">
                    <p id="section-toc.1-1.4.2.3.2.1.1"><a href="#section-4.3.1" class="auto internal xref">4.3.1</a>.  <a href="#name-stream-information" class="internal xref">Stream Information</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.3.2.2">
                    <p id="section-toc.1-1.4.2.3.2.2.1"><a href="#section-4.3.2" class="auto internal xref">4.3.2</a>.  <a href="#name-handshake-information" class="internal xref">Handshake Information</a></p>
</li>
                </ul>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5">
            <p id="section-toc.1-1.5.1"><a href="#section-5" class="auto internal xref">5</a>.  <a href="#name-quic-events-and-notificatio" class="internal xref">QUIC Events and Notifications</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.1">
                <p id="section-toc.1-1.5.2.1.1"><a href="#section-5.1" class="auto internal xref">5.1</a>.  <a href="#name-quic-notification-structure" class="internal xref">QUIC Notification Structure</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.1.2.1">
                    <p id="section-toc.1-1.5.2.1.2.1.1"><a href="#section-5.1.1" class="auto internal xref">5.1.1</a>.  <a href="#name-quic_event_stream_update" class="internal xref">QUIC_EVENT_STREAM_UPDATE</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.1.2.2">
                    <p id="section-toc.1-1.5.2.1.2.2.1"><a href="#section-5.1.2" class="auto internal xref">5.1.2</a>.  <a href="#name-quic_event_stream_max_strea" class="internal xref">QUIC_EVENT_STREAM_MAX_STREAM</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.1.2.3">
                    <p id="section-toc.1-1.5.2.1.2.3.1"><a href="#section-5.1.3" class="auto internal xref">5.1.3</a>.  <a href="#name-quic_event_connection_close" class="internal xref">QUIC_EVENT_CONNECTION_CLOSE</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.1.2.4">
                    <p id="section-toc.1-1.5.2.1.2.4.1"><a href="#section-5.1.4" class="auto internal xref">5.1.4</a>.  <a href="#name-quic_event_connection_migra" class="internal xref">QUIC_EVENT_CONNECTION_MIGRATION</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.1.2.5">
                    <p id="section-toc.1-1.5.2.1.2.5.1"><a href="#section-5.1.5" class="auto internal xref">5.1.5</a>.  <a href="#name-quic_event_key_update" class="internal xref">QUIC_EVENT_KEY_UPDATE</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.1.2.6">
                    <p id="section-toc.1-1.5.2.1.2.6.1"><a href="#section-5.1.6" class="auto internal xref">5.1.6</a>.  <a href="#name-quic_event_new_token" class="internal xref">QUIC_EVENT_NEW_TOKEN</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.2">
                <p id="section-toc.1-1.5.2.2.1"><a href="#section-5.2" class="auto internal xref">5.2</a>.  <a href="#name-notification-interest-optio" class="internal xref">Notification Interest Options</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.2.2.1">
                    <p id="section-toc.1-1.5.2.2.2.1.1"><a href="#section-5.2.1" class="auto internal xref">5.2.1</a>.  <a href="#name-quic_sockopt_event-option" class="internal xref">QUIC_SOCKOPT_EVENT Option</a></p>
</li>
                </ul>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6">
            <p id="section-toc.1-1.6.1"><a href="#section-6" class="auto internal xref">6</a>.  <a href="#name-socket-options" class="internal xref">Socket Options</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6.2.1">
                <p id="section-toc.1-1.6.2.1.1"><a href="#section-6.1" class="auto internal xref">6.1</a>.  <a href="#name-read-write-options" class="internal xref">Read/Write Options</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6.2.1.2.1">
                    <p id="section-toc.1-1.6.2.1.2.1.1"><a href="#section-6.1.1" class="auto internal xref">6.1.1</a>.  <a href="#name-quic_sockopt_event" class="internal xref">QUIC_SOCKOPT_EVENT</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6.2.1.2.2">
                    <p id="section-toc.1-1.6.2.1.2.2.1"><a href="#section-6.1.2" class="auto internal xref">6.1.2</a>.  <a href="#name-quic_sockopt_connection_clo" class="internal xref">QUIC_SOCKOPT_CONNECTION_CLOSE</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6.2.1.2.3">
                    <p id="section-toc.1-1.6.2.1.2.3.1"><a href="#section-6.1.3" class="auto internal xref">6.1.3</a>.  <a href="#name-quic_sockopt_transport_para" class="internal xref">QUIC_SOCKOPT_TRANSPORT_PARAM</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6.2.1.2.4">
                    <p id="section-toc.1-1.6.2.1.2.4.1"><a href="#section-6.1.4" class="auto internal xref">6.1.4</a>.  <a href="#name-quic_sockopt_token" class="internal xref">QUIC_SOCKOPT_TOKEN</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6.2.1.2.5">
                    <p id="section-toc.1-1.6.2.1.2.5.1"><a href="#section-6.1.5" class="auto internal xref">6.1.5</a>.  <a href="#name-quic_sockopt_alpn" class="internal xref">QUIC_SOCKOPT_ALPN</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6.2.1.2.6">
                    <p id="section-toc.1-1.6.2.1.2.6.1"><a href="#section-6.1.6" class="auto internal xref">6.1.6</a>.  <a href="#name-quic_sockopt_session_ticket" class="internal xref">QUIC_SOCKOPT_SESSION_TICKET</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6.2.1.2.7">
                    <p id="section-toc.1-1.6.2.1.2.7.1"><a href="#section-6.1.7" class="auto internal xref">6.1.7</a>.  <a href="#name-quic_sockopt_crypto_secret" class="internal xref">QUIC_SOCKOPT_CRYPTO_SECRET</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6.2.1.2.8">
                    <p id="section-toc.1-1.6.2.1.2.8.1"><a href="#section-6.1.8" class="auto internal xref">6.1.8</a>.  <a href="#name-quic_sockopt_transport_param" class="internal xref">QUIC_SOCKOPT_TRANSPORT_PARAM_EXT</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6.2.2">
                <p id="section-toc.1-1.6.2.2.1"><a href="#section-6.2" class="auto internal xref">6.2</a>.  <a href="#name-read-only-options" class="internal xref">Read-Only Options</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6.2.2.2.1">
                    <p id="section-toc.1-1.6.2.2.2.1.1"><a href="#section-6.2.1" class="auto internal xref">6.2.1</a>.  <a href="#name-quic_sockopt_stream_open" class="internal xref">QUIC_SOCKOPT_STREAM_OPEN</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6.2.3">
                <p id="section-toc.1-1.6.2.3.1"><a href="#section-6.3" class="auto internal xref">6.3</a>.  <a href="#name-write-only-options" class="internal xref">Write-Only Options</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6.2.3.2.1">
                    <p id="section-toc.1-1.6.2.3.2.1.1"><a href="#section-6.3.1" class="auto internal xref">6.3.1</a>.  <a href="#name-quic_sockopt_stream_reset" class="internal xref">QUIC_SOCKOPT_STREAM_RESET</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6.2.3.2.2">
                    <p id="section-toc.1-1.6.2.3.2.2.1"><a href="#section-6.3.2" class="auto internal xref">6.3.2</a>.  <a href="#name-quic_sockopt_stream_stop_se" class="internal xref">QUIC_SOCKOPT_STREAM_STOP_SENDING</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6.2.3.2.3">
                    <p id="section-toc.1-1.6.2.3.2.3.1"><a href="#section-6.3.3" class="auto internal xref">6.3.3</a>.  <a href="#name-quic_sockopt_connection_mig" class="internal xref">QUIC_SOCKOPT_CONNECTION_MIGRATION</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6.2.3.2.4">
                    <p id="section-toc.1-1.6.2.3.2.4.1"><a href="#section-6.3.4" class="auto internal xref">6.3.4</a>.  <a href="#name-quic_sockopt_key_update" class="internal xref">QUIC_SOCKOPT_KEY_UPDATE</a></p>
</li>
                </ul>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7">
            <p id="section-toc.1-1.7.1"><a href="#section-7" class="auto internal xref">7</a>.  <a href="#name-handshake-interface-for-ker" class="internal xref">Handshake Interface for Kernel Consumers</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8">
            <p id="section-toc.1-1.8.1"><a href="#section-8" class="auto internal xref">8</a>.  <a href="#name-iana-considerations" class="internal xref">IANA Considerations</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.9">
            <p id="section-toc.1-1.9.1"><a href="#section-9" class="auto internal xref">9</a>.  <a href="#name-security-considerations" class="internal xref">Security Considerations</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.10">
            <p id="section-toc.1-1.10.1"><a href="#section-10" class="auto internal xref">10</a>. <a href="#name-references" class="internal xref">References</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.10.2.1">
                <p id="section-toc.1-1.10.2.1.1"><a href="#section-10.1" class="auto internal xref">10.1</a>.  <a href="#name-normative-references" class="internal xref">Normative References</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.10.2.2">
                <p id="section-toc.1-1.10.2.2.1"><a href="#section-10.2" class="auto internal xref">10.2</a>.  <a href="#name-informative-references" class="internal xref">Informative References</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.11">
            <p id="section-toc.1-1.11.1"><a href="#appendix-A" class="auto internal xref">Appendix A</a>.  <a href="#name-example-for-multi-streaming" class="internal xref">Example For Multi-streaming Usage</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.12">
            <p id="section-toc.1-1.12.1"><a href="#appendix-B" class="auto internal xref">Appendix B</a>.  <a href="#name-example-for-session-consump" class="internal xref">Example For Session Consumption and 0-RTT transmission</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.13">
            <p id="section-toc.1-1.13.1"><a href="#appendix-C" class="auto internal xref">Appendix C</a>.  <a href="#name-example-for-kernel-consumer" class="internal xref">Example For Kernel Consumers Architecture Design</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.14">
            <p id="section-toc.1-1.14.1"><a href="#appendix-D" class="auto internal xref"></a><a href="#name-authors-address" class="internal xref">Author's Address</a></p>
</li>
        </ul>
</nav>
</section>
</div>
<section id="section-1">
      <h2 id="name-introduction">
<a href="#section-1" class="section-number selfRef">1. </a><a href="#name-introduction" class="section-name selfRef">Introduction</a>
      </h2>
<p id="section-1-1">The sockets API has provided a standard mapping of the Internet
Protocol suite to many operating systems.  Both TCP
<span>[<a href="#RFC9293" class="cite xref">RFC9293</a>]</span> and UDP <span>[<a href="#RFC0768" class="cite xref">RFC0768</a>]</span> have benefited
from this standard representation and access method across many diverse
platforms. SCTP <span>[<a href="#RFC6458" class="cite xref">RFC6458</a>]</span> has also created its own sockets
API. Base on <span>[<a href="#RFC6458" class="cite xref">RFC6458</a>]</span>, this document defines a method to
map the existing sockets API for use with In-kernel QUIC, providing both
a base for access to new features and compatibility so that most existing
TCP applications can be migrated to QUIC with few (if any) changes.<a href="#section-1-1" class="pilcrow">¶</a></p>
<p id="section-1-2">Some of the QUIC mechanisms cannot be adequately mapped to an
existing socket interface.  In some cases, it is more desirable to
have a new interface instead of using existing socket calls.<a href="#section-1-2" class="pilcrow">¶</a></p>
<section id="section-1.1">
        <h3 id="name-conventions">
<a href="#section-1.1" class="section-number selfRef">1.1. </a><a href="#name-conventions" class="section-name selfRef">Conventions</a>
        </h3>
<p id="section-1.1-1">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
"SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
document are to be interpreted as described in
<span>[<a href="#RFC2119" class="cite xref">RFC2119</a>]</span>.<a href="#section-1.1-1" class="pilcrow">¶</a></p>
</section>
</section>
<section id="section-2">
      <h2 id="name-data-types">
<a href="#section-2" class="section-number selfRef">2. </a><a href="#name-data-types" class="section-name selfRef">Data Types</a>
      </h2>
<p id="section-2-1">Whenever possible, Portable Operating System Interface (POSIX) data
types defined in IEEE-1003.1-2008 are used: uintN_t means an
unsigned integer of exactly N bits (e.g., uint16_t).  This document
also assumes the argument data types from POSIX when possible (e.g.,
the final argument to setsockopt() is a socklen_t value).  Whenever
buffer sizes are specified, the POSIX size_t data type is used.<a href="#section-2-1" class="pilcrow">¶</a></p>
</section>
<section id="section-3">
      <h2 id="name-interface">
<a href="#section-3" class="section-number selfRef">3. </a><a href="#name-interface" class="section-name selfRef">Interface</a>
      </h2>
<p id="section-3-1">A typical QUIC server uses the following socket calls in sequence to
prepare an endpoint for servicing requests:<a href="#section-3-1" class="pilcrow">¶</a></p>
<p id="section-3-2">o  socket()<a href="#section-3-2" class="pilcrow">¶</a></p>
<p id="section-3-3">o  bind()<a href="#section-3-3" class="pilcrow">¶</a></p>
<p id="section-3-4">o  listen()<a href="#section-3-4" class="pilcrow">¶</a></p>
<p id="section-3-5">o  accept()<a href="#section-3-5" class="pilcrow">¶</a></p>
<p id="section-3-6">o  quic_server_handshake()<a href="#section-3-6" class="pilcrow">¶</a></p>
<p id="section-3-7">o  recvmsg()<a href="#section-3-7" class="pilcrow">¶</a></p>
<p id="section-3-8">o  sendmsg()<a href="#section-3-8" class="pilcrow">¶</a></p>
<p id="section-3-9">o  close()<a href="#section-3-9" class="pilcrow">¶</a></p>
<p id="section-3-10">It is similar to a TCP server, except for the quic_server_handshake()
call, which handles the TLS message exchange to complete the handshake.
See <a href="#advanced_handshake" class="auto internal xref">Section 3.2.2</a>.<a href="#section-3-10" class="pilcrow">¶</a></p>
<p id="section-3-11">All TLS handshake messages carried in QUIC packets MUST be processed in
userspace. When a Client Initial packet is received, it triggers accept()
to create a new socket and return. However, the TLS handshake message
contained in this packet will be processed by quic_server_handshake() via
the newly created socket.<a href="#section-3-11" class="pilcrow">¶</a></p>
<p id="section-3-12">A typical QUIC client uses the following calls in sequence to set up
a connection with a server to request services:<a href="#section-3-12" class="pilcrow">¶</a></p>
<p id="section-3-13">o  socket()<a href="#section-3-13" class="pilcrow">¶</a></p>
<p id="section-3-14">o  connect()<a href="#section-3-14" class="pilcrow">¶</a></p>
<p id="section-3-15">o  quic_client_handshake()<a href="#section-3-15" class="pilcrow">¶</a></p>
<p id="section-3-16">o  sendmsg()<a href="#section-3-16" class="pilcrow">¶</a></p>
<p id="section-3-17">o  recvmsg()<a href="#section-3-17" class="pilcrow">¶</a></p>
<p id="section-3-18">o  close()<a href="#section-3-18" class="pilcrow">¶</a></p>
<p id="section-3-19">It is similar to a TCP client, except for the quic_client_handshake()
call, which handles the TLS message exchange to complete the handshake.
See <a href="#advanced_handshake" class="auto internal xref">Section 3.2.2</a>.<a href="#section-3-19" class="pilcrow">¶</a></p>
<p id="section-3-20">On the client side, connect() SHOULD not send any packets to the server.
Instead, all TLS handshake messages are generated by the TLS library and
sent in quic_client_handshake().<a href="#section-3-20" class="pilcrow">¶</a></p>
<p id="section-3-21">In the implementation, one QUIC socket represents a single QUIC
connection and MAY manage multiple UDP sockets simultaneously to support
connection migration or future multipath features. Conversely, a single
lower-layer UDP socket MAY serve multiple QUIC sockets.<a href="#section-3-21" class="pilcrow">¶</a></p>
<section id="section-3.1">
        <h3 id="name-basic-operation">
<a href="#section-3.1" class="section-number selfRef">3.1. </a><a href="#name-basic-operation" class="section-name selfRef">Basic Operation</a>
        </h3>
<section id="section-3.1.1">
          <h4 id="name-socket">
<a href="#section-3.1.1" class="section-number selfRef">3.1.1. </a><a href="#name-socket" class="section-name selfRef">socket()</a>
          </h4>
<p id="section-3.1.1-1">Applications use socket() to create a socket descriptor to represent
an QUIC endpoint.<a href="#section-3.1.1-1" class="pilcrow">¶</a></p>
<p id="section-3.1.1-2">The function prototype is<a href="#section-3.1.1-2" class="pilcrow">¶</a></p>
<div class="C lang-language sourcecode" id="section-3.1.1-3">
<pre>
int socket(int domain,
           int type,
           int protocol);
</pre><a href="#section-3.1.1-3" class="pilcrow">¶</a>
</div>
<p id="section-3.1.1-4">and one uses PF_INET or PF_INET6 as the domain, SOCK_STREAM or
SOCK_DGRAM as the type, and IPPROTO_QUIC as the protocol.<a href="#section-3.1.1-4" class="pilcrow">¶</a></p>
<p id="section-3.1.1-5">Note that QUIC does not have a protocol number allocated by IANA.
Similar to IPPROTO_MPTCP in Linux, IPPROTO_QUIC is simply a value used
when opening a QUIC socket, and its value MAY vary depending on the
implementation.<a href="#section-3.1.1-5" class="pilcrow">¶</a></p>
<p id="section-3.1.1-6">The function returns a socket descriptor or -1 in case of an error.
Using the PF_INET domain indicates the creation of an endpoint that MUST
use only IPv4 addresses, while PF_INET6 creates an endpoint that MAY use
both IPv6 and IPv4 addresses.<a href="#section-3.1.1-6" class="pilcrow">¶</a></p>
</section>
<section id="section-3.1.2">
          <h4 id="name-bind">
<a href="#section-3.1.2" class="section-number selfRef">3.1.2. </a><a href="#name-bind" class="section-name selfRef">bind()</a>
          </h4>
<p id="section-3.1.2-1">Applications use bind() to specify with which local address and port
the QUIC endpoint SHOULD associate itself.<a href="#section-3.1.2-1" class="pilcrow">¶</a></p>
<p id="section-3.1.2-2">The function prototype of bind() is<a href="#section-3.1.2-2" class="pilcrow">¶</a></p>
<div class="C lang-language sourcecode" id="section-3.1.2-3">
<pre>
int bind(int sd,
         struct sockaddr *addr,
         socklen_t addrlen);
</pre><a href="#section-3.1.2-3" class="pilcrow">¶</a>
</div>
<p id="section-3.1.2-4">and the arguments are<a href="#section-3.1.2-4" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-3.1.2-5.1">sd:  The socket descriptor returned by socket().<a href="#section-3.1.2-5.1" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-3.1.2-5.2">addr:  The address structure (struct sockaddr_in for an IPv4 address
or struct sockaddr_in6 for an IPv6 address. See <span>[<a href="#RFC3493" class="cite xref">RFC3493</a>]</span>).<a href="#section-3.1.2-5.2" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-3.1.2-5.3">addrlen:  The size of the address structure.<a href="#section-3.1.2-5.3" class="pilcrow">¶</a>
</li>
          </ul>
<p id="section-3.1.2-6">bind() returns 0 on success and -1 in case of an error.<a href="#section-3.1.2-6" class="pilcrow">¶</a></p>
<p id="section-3.1.2-7">Applications cannot call bind() multiple times to associate multiple
addresses with an endpoint. After the first bind() call, all subsequent
calls will return an error. However, multiple applications MAY bind()
to the same address and port, sharing the same lower UDP socket in
kernel.<a href="#section-3.1.2-7" class="pilcrow">¶</a></p>
<p id="section-3.1.2-8">The IP address part of addr MAY be specified as a wildcard (e.g.,
INADDR_ANY for IPv4 or IN6ADDR_ANY_INIT or in6addr_any for IPv6). An
error will be returned if the IPv4 sin_port or IPv6 sin6_port is set
to 0.<a href="#section-3.1.2-8" class="pilcrow">¶</a></p>
<p id="section-3.1.2-9">If bind() is not called before connect() on the client, the system will
automatically select an ephemeral port to bind during connect()..<a href="#section-3.1.2-9" class="pilcrow">¶</a></p>
<p id="section-3.1.2-10">Completing the bind() process does not permit the QUIC endpoint to
accept inbound QUIC connection requests on the server. This capability
is only enabled after a listen() system call, as described below,
is performed on the socket.<a href="#section-3.1.2-10" class="pilcrow">¶</a></p>
</section>
<section id="section-3.1.3">
          <h4 id="name-listen">
<a href="#section-3.1.3" class="section-number selfRef">3.1.3. </a><a href="#name-listen" class="section-name selfRef">listen()</a>
          </h4>
<p id="section-3.1.3-1">An application uses listen() to mark a socket as being able to accept
new connections.<a href="#section-3.1.3-1" class="pilcrow">¶</a></p>
<p id="section-3.1.3-2">The function prototype is<a href="#section-3.1.3-2" class="pilcrow">¶</a></p>
<div class="C lang-language sourcecode" id="section-3.1.3-3">
<pre>
int listen(int sd,
           int backlog);
</pre><a href="#section-3.1.3-3" class="pilcrow">¶</a>
</div>
<p id="section-3.1.3-4">and the arguments are<a href="#section-3.1.3-4" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-3.1.3-5.1">sd:  The socket descriptor of the endpoint.<a href="#section-3.1.3-5.1" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-3.1.3-5.2">backlog:  If backlog is non-zero, enable listening, else disable
listening.<a href="#section-3.1.3-5.2" class="pilcrow">¶</a>
</li>
          </ul>
<p id="section-3.1.3-6">listen() returns 0 on success and -1 in case of an error.<a href="#section-3.1.3-6" class="pilcrow">¶</a></p>
<p id="section-3.1.3-7">The implementation SHOULD allow kernel to parse the ALPN from a
Client Initial packet and direct the incoming request based on it to
different listening sockets (binding to the same address and port).
These sockets could belong to different user processes or kernel
threads. The ALPNs for sockets are set via socket option ALPN
<a href="#sockopt_alpn" class="auto internal xref">Section 6.1.5</a> before calling listen().<a href="#section-3.1.3-7" class="pilcrow">¶</a></p>
</section>
<section id="section-3.1.4">
          <h4 id="name-accept">
<a href="#section-3.1.4" class="section-number selfRef">3.1.4. </a><a href="#name-accept" class="section-name selfRef">accept()</a>
          </h4>
<p id="section-3.1.4-1">Applications use the accept() call to remove an QUIC connection request
from the accept queue of the endpoint.  A new socket descriptor will be
returned from accept() to represent the newly formed connection
request.<a href="#section-3.1.4-1" class="pilcrow">¶</a></p>
<p id="section-3.1.4-2">The function prototype is<a href="#section-3.1.4-2" class="pilcrow">¶</a></p>
<div class="C lang-language sourcecode" id="section-3.1.4-3">
<pre>
int accept(int sd,
           struct sockaddr *addr,
           socklen_t *addrlen);
</pre><a href="#section-3.1.4-3" class="pilcrow">¶</a>
</div>
<p id="section-3.1.4-4">and the arguments are<a href="#section-3.1.4-4" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-3.1.4-5.1">sd:  The socket descriptor of the endpoint.<a href="#section-3.1.4-5.1" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-3.1.4-5.2">addr:  The address structure (struct sockaddr_in for an IPv4 address
or struct sockaddr_in6 for an IPv6 address. See <span>[<a href="#RFC3542" class="cite xref">RFC3542</a>]</span>).<a href="#section-3.1.4-5.2" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-3.1.4-5.3">addrlen:  The size of the address structure.<a href="#section-3.1.4-5.3" class="pilcrow">¶</a>
</li>
          </ul>
<p id="section-3.1.4-6">The function returns the socket descriptor for the newly formed
connection request on success and -1 in case of an error.<a href="#section-3.1.4-6" class="pilcrow">¶</a></p>
<p id="section-3.1.4-7">Note that the incoming Client Initial packet triggers the accept() call,
and the TLS message carried by the Client Initial packet will be queued in
the receive queue of the socket returned by accept(). This TLS message will
then be received and processed by userspace through the newly returned
socket, ensuring that the TLS handshake is completed in userspace.<a href="#section-3.1.4-7" class="pilcrow">¶</a></p>
</section>
<section id="section-3.1.5">
          <h4 id="name-connect">
<a href="#section-3.1.5" class="section-number selfRef">3.1.5. </a><a href="#name-connect" class="section-name selfRef">connect()</a>
          </h4>
<p id="section-3.1.5-1">Applications use connect() to perform routing and determine the
appropriate source address and port to bind if bind() has not been called.
Additionally, connect() initializes the connection ID and installs the
initial keys necessary for encrypting handshake packets.<a href="#section-3.1.5-1" class="pilcrow">¶</a></p>
<p id="section-3.1.5-2">The function prototype is<a href="#section-3.1.5-2" class="pilcrow">¶</a></p>
<div class="C lang-language sourcecode" id="section-3.1.5-3">
<pre>
int connect(int sd,
            const struct sockaddr *addr,
            socklen_t addrlen);
</pre><a href="#section-3.1.5-3" class="pilcrow">¶</a>
</div>
<p id="section-3.1.5-4">and the arguments are<a href="#section-3.1.5-4" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-3.1.5-5.1">sd:  The socket descriptor of the endpoint.<a href="#section-3.1.5-5.1" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-3.1.5-5.2">addr:  The address structure (struct sockaddr_in for an IPv4 address
or struct sockaddr_in6 for an IPv6 address. See <span>[<a href="#RFC3542" class="cite xref">RFC3542</a>]</span>).<a href="#section-3.1.5-5.2" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-3.1.5-5.3">addrlen:  The size of the address structure.<a href="#section-3.1.5-5.3" class="pilcrow">¶</a>
</li>
          </ul>
<p id="section-3.1.5-6">connect() returns 0 on success and -1 on error.<a href="#section-3.1.5-6" class="pilcrow">¶</a></p>
<p id="section-3.1.5-7">connect() MUST be called before sending any handshake message.<a href="#section-3.1.5-7" class="pilcrow">¶</a></p>
</section>
<section id="section-3.1.6">
          <h4 id="name-close">
<a href="#section-3.1.6" class="section-number selfRef">3.1.6. </a><a href="#name-close" class="section-name selfRef">close()</a>
          </h4>
<p id="section-3.1.6-1">Applications use close() to gracefully close down an connection.<a href="#section-3.1.6-1" class="pilcrow">¶</a></p>
<p id="section-3.1.6-2">The function prototype is<a href="#section-3.1.6-2" class="pilcrow">¶</a></p>
<div class="C lang-language sourcecode" id="section-3.1.6-3">
<pre>
int close(int sd);
</pre><a href="#section-3.1.6-3" class="pilcrow">¶</a>
</div>
<p id="section-3.1.6-4">and the arguments are<a href="#section-3.1.6-4" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-3.1.6-5.1">sd:  The socket descriptor of the connection to be closed.<a href="#section-3.1.6-5.1" class="pilcrow">¶</a>
</li>
          </ul>
<p id="section-3.1.6-6">close() returns 0 on success and -1 in case of an error.<a href="#section-3.1.6-6" class="pilcrow">¶</a></p>
<p id="section-3.1.6-7">After an application calls close() on a socket descriptor, no further
socket operations will succeed on that descriptor.<a href="#section-3.1.6-7" class="pilcrow">¶</a></p>
<p id="section-3.1.6-8">close() will send CLOSE frame to the peer, the close information MAY
be set via socket option CONNECTION_CLOSE <a href="#sockopt_close" class="auto internal xref">Section 6.1.2</a>
before calling close().<a href="#section-3.1.6-8" class="pilcrow">¶</a></p>
</section>
<section id="section-3.1.7">
          <h4 id="name-shutdown">
<a href="#section-3.1.7" class="section-number selfRef">3.1.7. </a><a href="#name-shutdown" class="section-name selfRef">shutdown()</a>
          </h4>
<p id="section-3.1.7-1">QUIC differs from TCP in that it does not have half close
semantics.<a href="#section-3.1.7-1" class="pilcrow">¶</a></p>
<p id="section-3.1.7-2">The function prototypes are<a href="#section-3.1.7-2" class="pilcrow">¶</a></p>
<div class="C lang-language sourcecode" id="section-3.1.7-3">
<pre>
int shutdown(int sd,
             int how);
</pre><a href="#section-3.1.7-3" class="pilcrow">¶</a>
</div>
<p id="section-3.1.7-4">and the arguments are<a href="#section-3.1.7-4" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-3.1.7-5.1">sd:  The socket descriptor of the connection to be closed.<a href="#section-3.1.7-5.1" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-3.1.7-5.2">
              <p id="section-3.1.7-5.2.1">how:  Specifies the type of shutdown<a href="#section-3.1.7-5.2.1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-3.1.7-5.2.2.1">SHUT_RD: Disables further receive operations, the socket state is
  set to closed.<a href="#section-3.1.7-5.2.2.1" class="pilcrow">¶</a>
</li>
                <li class="normal" id="section-3.1.7-5.2.2.2">SHUT_WR: Disables further send operations, after sending CLOSE frame,
  the socket state is set to closed.<a href="#section-3.1.7-5.2.2.2" class="pilcrow">¶</a>
</li>
                <li class="normal" id="section-3.1.7-5.2.2.3">SHUT_RDWR: Similar to SHUT_WR.<a href="#section-3.1.7-5.2.2.3" class="pilcrow">¶</a>
</li>
              </ul>
</li>
          </ul>
<p id="section-3.1.7-6">shutdown() returns 0 on success and -1 in case of an error.<a href="#section-3.1.7-6" class="pilcrow">¶</a></p>
<p id="section-3.1.7-7">Note that users MAY use SHUT_WR to send the CLOSE frame multiple times.
The implementation MUST be capable of unblocking sendmsg(), recvmsg(), and
accept() operations with SHUT_RDWR.<a href="#section-3.1.7-7" class="pilcrow">¶</a></p>
</section>
<section id="section-3.1.8">
          <h4 id="name-sendmsg-and-recvmsg">
<a href="#section-3.1.8" class="section-number selfRef">3.1.8. </a><a href="#name-sendmsg-and-recvmsg" class="section-name selfRef">sendmsg() and recvmsg()</a>
          </h4>
<p id="section-3.1.8-1">An application uses the sendmsg() and recvmsg() calls to transmit
data to and receive data from its peer.<a href="#section-3.1.8-1" class="pilcrow">¶</a></p>
<p id="section-3.1.8-2">The function prototypes are<a href="#section-3.1.8-2" class="pilcrow">¶</a></p>
<div class="C lang-language sourcecode" id="section-3.1.8-3">
<pre>
ssize_t sendmsg(int sd,
                const struct msghdr *message,
                int flags);
ssize_t recvmsg(int sd,
                struct msghdr *message,
                int flags);
</pre><a href="#section-3.1.8-3" class="pilcrow">¶</a>
</div>
<p id="section-3.1.8-4">and the arguments are<a href="#section-3.1.8-4" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-3.1.8-5.1">sd:  The socket descriptor of the endpoint.<a href="#section-3.1.8-5.1" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-3.1.8-5.2">message:  Pointer to the msghdr structure that contains a single user
message and possibly some ancillary data. See <a href="#struct" class="auto internal xref">Section 4</a>
for a complete description of the data structures.<a href="#section-3.1.8-5.2" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-3.1.8-5.3">flags:  No new flags are defined for QUIC at this level. See
<a href="#struct" class="auto internal xref">Section 4</a> for QUIC-specific flags used in the
msghdr structure.<a href="#section-3.1.8-5.3" class="pilcrow">¶</a>
</li>
          </ul>
<p id="section-3.1.8-6">sendmsg() returns the number of bytes accepted by kernel or -1 in
case of an error.  recvmsg() returns the number of bytes received or
-1 in case of an error.<a href="#section-3.1.8-6" class="pilcrow">¶</a></p>
<p id="section-3.1.8-7">As described in <a href="#struct" class="auto internal xref">Section 4</a>, different types of ancillary
data MAY be sent and received along with user data.<a href="#section-3.1.8-7" class="pilcrow">¶</a></p>
<p id="section-3.1.8-8">During Handshake, users SHOULD use sendmsg() and recvmsg() with
Handshake msg_control <a href="#struct_handshake" class="auto internal xref">Section 4.3.2</a> to send raw TLS
messages to and receive from kernel, and to exchange TLS messages in
userspace with the help of a third-party TLS library, such as GnuTLS.
A pair of high-level APIs MAY be defined to wrap the handshake process
in userspace. See <a href="#advanced_handshake" class="auto internal xref">Section 3.2.2</a>.<a href="#section-3.1.8-8" class="pilcrow">¶</a></p>
<p id="section-3.1.8-9">Post Handshake, users SHOULD use sendmsg() and recvmsg() with Stream
msg_control <a href="#struct_stream" class="auto internal xref">Section 4.3.1</a> to send data msgs to and
receive from kernel with stream_id and stream_flags. One pair of high
level APIs MAY be defined to wrap Stream msg_control.
See <a href="#advanced_stream" class="auto internal xref">Section 3.2.1</a>.<a href="#section-3.1.8-9" class="pilcrow">¶</a></p>
</section>
<section id="section-3.1.9">
          <h4 id="name-send-recv-read-and-write">
<a href="#section-3.1.9" class="section-number selfRef">3.1.9. </a><a href="#name-send-recv-read-and-write" class="section-name selfRef">send(), recv(), read() and write()</a>
          </h4>
<p id="section-3.1.9-1">Applications MAY use send() and recv() to transmit and receive data with
basic access to the peer.<a href="#section-3.1.9-1" class="pilcrow">¶</a></p>
<p id="section-3.1.9-2">The function prototypes are<a href="#section-3.1.9-2" class="pilcrow">¶</a></p>
<div class="C lang-language sourcecode" id="section-3.1.9-3">
<pre>
ssize_t send(int sd,
             const void *msg,
             size_t len,
             int flags);
ssize_t recv(int sd,
             void *buf,
             size_t len,
             int flags);
</pre><a href="#section-3.1.9-3" class="pilcrow">¶</a>
</div>
<p id="section-3.1.9-4">and the arguments are<a href="#section-3.1.9-4" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-3.1.9-5.1">sd:  The socket descriptor of the endpoint.<a href="#section-3.1.9-5.1" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-3.1.9-5.2">msg:  The message to be sent.<a href="#section-3.1.9-5.2" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-3.1.9-5.3">len:  The size of the message or the size of the buffer.<a href="#section-3.1.9-5.3" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-3.1.9-5.4">flags:  (described below).<a href="#section-3.1.9-5.4" class="pilcrow">¶</a>
</li>
          </ul>
<p id="section-3.1.9-6">send() returns the number of bytes accepted by kernel or -1 in
case of an error.  recv() returns the number of bytes received or
-1 in case of an error.<a href="#section-3.1.9-6" class="pilcrow">¶</a></p>
<p id="section-3.1.9-7">As the ancillary data (msg_control field) cannot be used, the flags will
operate as described in <a href="#struct_msghdr" class="auto internal xref">Section 4.1</a>, but without the
context provided by Stream msg_control. This means that while sending, the
flags function as intended, but during receiving, users won't be able to
receive any flags from the kernel, making it impossible to determine the
end of the stream data.<a href="#section-3.1.9-7" class="pilcrow">¶</a></p>
<p id="section-3.1.9-8">Both send() and recv() MUST NOT be used to transmit or receive TLS
messages because, without ancillary data, Handshake Information cannot be
carried.<a href="#section-3.1.9-8" class="pilcrow">¶</a></p>
<p id="section-3.1.9-9">Alternatively, applications can use read() and write() to transmit and
receive data to and from a peer. These functions are similar to recv() and
send() but offer less functionality, as they do not allow the use of a
flags parameter.<a href="#section-3.1.9-9" class="pilcrow">¶</a></p>
</section>
<section id="section-3.1.10">
          <h4 id="name-setsockopt-and-getsockopt">
<a href="#section-3.1.10" class="section-number selfRef">3.1.10. </a><a href="#name-setsockopt-and-getsockopt" class="section-name selfRef">setsockopt() and getsockopt()</a>
          </h4>
<p id="section-3.1.10-1">Applications use setsockopt() and getsockopt() to set or retrieve
socket options.  Socket options are used to change the default
behavior of socket calls.  They are described in <a href="#sockopt" class="auto internal xref">Section 6</a>
.<a href="#section-3.1.10-1" class="pilcrow">¶</a></p>
<p id="section-3.1.10-2">The function prototypes are<a href="#section-3.1.10-2" class="pilcrow">¶</a></p>
<div class="C lang-language sourcecode" id="section-3.1.10-3">
<pre>
int getsockopt(int sd,
               int level,
               int optname,
               void *optval,
               socklen_t *optlen);
int setsockopt(int sd,
               int level,
               int optname,
               const void *optval,
               socklen_t optlen);
</pre><a href="#section-3.1.10-3" class="pilcrow">¶</a>
</div>
<p id="section-3.1.10-4">and the arguments are<a href="#section-3.1.10-4" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-3.1.10-5.1">sd:  The socket descriptor.<a href="#section-3.1.10-5.1" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-3.1.10-5.2">level:  Set to SOL_QUIC for all QUIC options.<a href="#section-3.1.10-5.2" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-3.1.10-5.3">optname:  The option name.<a href="#section-3.1.10-5.3" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-3.1.10-5.4">optval:  The buffer to store the value of the option.<a href="#section-3.1.10-5.4" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-3.1.10-5.5">optlen:  The size of the buffer (or the length of the option
returned).<a href="#section-3.1.10-5.5" class="pilcrow">¶</a>
</li>
          </ul>
<p id="section-3.1.10-6">These functions return 0 on success and -1 in case of an error.<a href="#section-3.1.10-6" class="pilcrow">¶</a></p>
</section>
<section id="section-3.1.11">
          <h4 id="name-getsockname-and-getpeername">
<a href="#section-3.1.11" class="section-number selfRef">3.1.11. </a><a href="#name-getsockname-and-getpeername" class="section-name selfRef">getsockname() and getpeername()</a>
          </h4>
<p id="section-3.1.11-1">Applications use getsockname() to retrieve the locally bound socket
address of the specified socket and use getpeername() to retrieve the
peer socket address. These functions are particularly useful when
connection migration occurs and the corresponding event notifications
are not enabled.<a href="#section-3.1.11-1" class="pilcrow">¶</a></p>
<p id="section-3.1.11-2">The function prototypes are<a href="#section-3.1.11-2" class="pilcrow">¶</a></p>
<div class="C lang-language sourcecode" id="section-3.1.11-3">
<pre>
int getsockname(int sd,
                struct sockaddr *address,
                socklen_t *len);
int getpeername(int sd,
                struct sockaddr *address,
                socklen_t *len);
</pre><a href="#section-3.1.11-3" class="pilcrow">¶</a>
</div>
<p id="section-3.1.11-4">and the arguments are<a href="#section-3.1.11-4" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-3.1.11-5.1">sd:  The socket descriptor to be queried.<a href="#section-3.1.11-5.1" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-3.1.11-5.2">address:  On return, one locally bound or peer address (chosen by the
QUIC stack) is stored in this buffer.  If the socket is an IPv4 socket,
the address will be IPv4.  If the socket is an IPv6 socket, the
address will be either an IPv6 or IPv4 address.<a href="#section-3.1.11-5.2" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-3.1.11-5.3">len:  The caller SHOULD set the length of the address here.  On
return, this is set to the length of the returned address.<a href="#section-3.1.11-5.3" class="pilcrow">¶</a>
</li>
          </ul>
<p id="section-3.1.11-6">These functions return 0 on success and -1 in case of an error.<a href="#section-3.1.11-6" class="pilcrow">¶</a></p>
<p id="section-3.1.11-7">If the actual length of the address is greater than the length of the
supplied sockaddr structure, the stored address will be truncated.<a href="#section-3.1.11-7" class="pilcrow">¶</a></p>
</section>
</section>
<section id="section-3.2">
        <h3 id="name-advanced-operation">
<a href="#section-3.2" class="section-number selfRef">3.2. </a><a href="#name-advanced-operation" class="section-name selfRef">Advanced Operation</a>
        </h3>
<div id="advanced_stream">
<section id="section-3.2.1">
          <h4 id="name-quic_sendmsg-and-quic_recvm">
<a href="#section-3.2.1" class="section-number selfRef">3.2.1. </a><a href="#name-quic_sendmsg-and-quic_recvm" class="section-name selfRef">quic_sendmsg() and quic_recvmsg()</a>
          </h4>
<p id="section-3.2.1-1">An application uses quic_sendmsg() and quic_recvmsg() calls to
transmit data to and receive data from its peer with stream_id and
flags.<a href="#section-3.2.1-1" class="pilcrow">¶</a></p>
<p id="section-3.2.1-2">The function prototypes are<a href="#section-3.2.1-2" class="pilcrow">¶</a></p>
<div class="C lang-language sourcecode" id="section-3.2.1-3">
<pre>
ssize_t quic_sendmsg(int sd,
                     const void *msg,
                     size_t len,
                     uint64_t sid,
                     uint32_t flags);
ssize_t quic_recvmsg(int sd,
                     void *msg,
                     size_t len,
                     uint64_t *sid,
                     uint32_t *flags);
</pre><a href="#section-3.2.1-3" class="pilcrow">¶</a>
</div>
<p id="section-3.2.1-4">and the arguments are<a href="#section-3.2.1-4" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-3.2.1-5.1">sd:  The socket descriptor.<a href="#section-3.2.1-5.1" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-3.2.1-5.2">msg:  The message buffer to be filled.<a href="#section-3.2.1-5.2" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-3.2.1-5.3">len:  The length of the message buffer.<a href="#section-3.2.1-5.3" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-3.2.1-5.4">sid:  stream_id to point for sending or to get for receiving.<a href="#section-3.2.1-5.4" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-3.2.1-5.5">flags:  function as stream_flags in <a href="#struct_stream" class="auto internal xref">Section 4.3.1</a> and
msg_flags/flags in <a href="#struct_msghdr" class="auto internal xref">Section 4.1</a>.<a href="#section-3.2.1-5.5" class="pilcrow">¶</a>
</li>
          </ul>
<p id="section-3.2.1-6">quic_sendmsg() returns the number of bytes accepted by kernel or -1
in case of an error.  quic_recvmsg() returns the number of bytes received
or -1 in case of an error.<a href="#section-3.2.1-6" class="pilcrow">¶</a></p>
<p id="section-3.2.1-7">These functions wrap the sendmsg() and recvmsg() with Stream information
msg_control, and are important for using QUIC multiple streams. See an
example in <a href="#example_stream" class="auto internal xref">Appendix A</a><a href="#section-3.2.1-7" class="pilcrow">¶</a></p>
</section>
</div>
<div id="advanced_handshake">
<section id="section-3.2.2">
          <h4 id="name-quic_client_handshake-and-q">
<a href="#section-3.2.2" class="section-number selfRef">3.2.2. </a><a href="#name-quic_client_handshake-and-q" class="section-name selfRef">quic_client_handshake() and quic_server_handshake()</a>
          </h4>
<p id="section-3.2.2-1">An application uses quic_client_handshake() or quic_server_handshake()
to initiate a QUIC handshake, either with Certificate or PSK mode, from
the client or server side..<a href="#section-3.2.2-1" class="pilcrow">¶</a></p>
<p id="section-3.2.2-2">The function prototypes are<a href="#section-3.2.2-2" class="pilcrow">¶</a></p>
<div class="C lang-language sourcecode" id="section-3.2.2-3">
<pre>
int quic_server_handshake(int sd, ...);
int quic_client_handshake(int sd, ...);
</pre><a href="#section-3.2.2-3" class="pilcrow">¶</a>
</div>
<p id="section-3.2.2-4">and the arguments are<a href="#section-3.2.2-4" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-3.2.2-5.1">sd:  The socket descriptor.<a href="#section-3.2.2-5.1" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-3.2.2-5.2">...:  Additional arguments, implementation-specific.<a href="#section-3.2.2-5.2" class="pilcrow">¶</a>
</li>
          </ul>
<p id="section-3.2.2-6">These functions return 0 for success and errcode in case of an
error.<a href="#section-3.2.2-6" class="pilcrow">¶</a></p>
<p id="section-3.2.2-7">Implementation guidelines for handling TLS and QUIC communications
between kernel and userspace:<a href="#section-3.2.2-7" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-3.2.2-8.1">
              <p id="section-3.2.2-8.1.1">Handling Raw TLS Messages:<a href="#section-3.2.2-8.1.1" class="pilcrow">¶</a></p>
<p id="section-3.2.2-8.1.2">The implementation of these functions SHOULD use sendmsg() and recvmsg()
with Handshake msg_control <a href="#struct_handshake" class="auto internal xref">Section 4.3.2</a> to send and
receive raw TLS messages to and from kernel, and exchange them in userspace
via a TLS library like GnuTLS.<a href="#section-3.2.2-8.1.2" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-3.2.2-8.2">
              <p id="section-3.2.2-8.2.1">Retrieving and Setting Handshake Parameters:<a href="#section-3.2.2-8.2.1" class="pilcrow">¶</a></p>
<p id="section-3.2.2-8.2.2">The implementation SHOULD use socket options to retrieve handshake
parameters from kernel for building TLS messages, such as ALPN
<a href="#sockopt_alpn" class="auto internal xref">Section 6.1.5</a>, TRANSPORT_PARAM
TRANSPORT_PARAM <a href="#sockopt_transport_param" class="auto internal xref">Section 6.1.3</a>, and
TRANSPORT_PARAM_EXT <a href="#sockopt_transport_param_ext" class="auto internal xref">Section 6.1.8</a>.
They SHOULD set handshake parameters in kernel for constructing QUIC
packets, including TRANSPORT_PARAM_EXT
<a href="#sockopt_transport_param_ext" class="auto internal xref">Section 6.1.8</a> and CRYPTO_SECRET
<a href="#sockopt_crypto_secret" class="auto internal xref">Section 6.1.7</a>.<a href="#section-3.2.2-8.2.2" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-3.2.2-8.3">
              <p id="section-3.2.2-8.3.1">Session Resumption and Early or 0-RTT Data:<a href="#section-3.2.2-8.3.1" class="pilcrow">¶</a></p>
<p id="section-3.2.2-8.3.2">These functions MAY support session resumption by retrieving the session
ticket from kernel using socket option SESSION_TICKET
<a href="#sockopt_session_ticket" class="auto internal xref">Section 6.1.6</a>. They MAY use sendmsg() and
recvmsg() with Stream msg_control <a href="#struct_stream" class="auto internal xref">Section 4.3.1</a> to handle
early or 0-RTT data before the completion of the handshake for userspace
applications.<a href="#section-3.2.2-8.3.2" class="pilcrow">¶</a></p>
<p id="section-3.2.2-8.3.3">However, for kernel consumers, since user data is managed entirely
within the kernel, early or 0-RTT data SHOULD be buffered using sendmsg()
before invoking the handshake request to userspace. Additionally, TLS
session ticket message MUST be handled before user data. Refer to
receive_session_ticket parameter in socket option TRANSPORT_PARAM
<a href="#sockopt_transport_param" class="auto internal xref">Section 6.1.3</a>.<a href="#section-3.2.2-8.3.3" class="pilcrow">¶</a></p>
</li>
          </ul>
</section>
</div>
</section>
</section>
<div id="struct">
<section id="section-4">
      <h2 id="name-data-structures">
<a href="#section-4" class="section-number selfRef">4. </a><a href="#name-data-structures" class="section-name selfRef">Data Structures</a>
      </h2>
<p id="section-4-1">This section discusses key data structures specific to QUIC that are
used with sendmsg() and recvmsg() calls. These structures control QUIC
endpoint operations and provide access to ancillary information and
notifications.<a href="#section-4-1" class="pilcrow">¶</a></p>
<div id="struct_msghdr">
<section id="section-4.1">
        <h3 id="name-the-msghdr-and-cmsghdr-stru">
<a href="#section-4.1" class="section-number selfRef">4.1. </a><a href="#name-the-msghdr-and-cmsghdr-stru" class="section-name selfRef">The msghdr and cmsghdr Structures</a>
        </h3>
<p id="section-4.1-1">The msghdr structure used in sendmsg() and recvmsg() calls, along with
the ancillary data it carries, is crucial for applications to set and
retrieve various control information from the QUIC endpoint.<a href="#section-4.1-1" class="pilcrow">¶</a></p>
<p id="section-4.1-2">The msghdr and the related cmsghdr structures are defined and
discussed in detail in <span>[<a href="#RFC3542" class="cite xref">RFC3542</a>]</span>.  They are defined as<a href="#section-4.1-2" class="pilcrow">¶</a></p>
<div class="C lang-language sourcecode" id="section-4.1-3">
<pre>
struct msghdr {
  void *msg_name;           /* ptr to socket address structure */
  socklen_t msg_namelen;    /* size of socket address structure */
  struct iovec *msg_iov;    /* scatter/gather array */
  int msg_iovlen;           /* # elements in msg_iov */
  void *msg_control;        /* ancillary data */
  socklen_t msg_controllen; /* ancillary data buffer length */
  int msg_flags;            /* flags on message */
};

struct cmsghdr {
  socklen_t cmsg_len; /* # bytes, including this header */
  int cmsg_level;     /* originating protocol */
  int cmsg_type;      /* protocol-specific type */
                      /* followed by unsigned char cmsg_data[]; */
};
</pre><a href="#section-4.1-3" class="pilcrow">¶</a>
</div>
<p id="section-4.1-4">The msg_name is not used when sending a message with sendmsg().<a href="#section-4.1-4" class="pilcrow">¶</a></p>
<p id="section-4.1-5">The scatter/gather buffers, or I/O vectors (pointed to by the msg_iov
field) are treated by QUIC as a single user message for both sendmsg()
and recvmsg().<a href="#section-4.1-5" class="pilcrow">¶</a></p>
<p id="section-4.1-6">The QUIC stack uses the ancillary data (msg_control field) to
communicate the attributes, such as QUIC_STREAM_INFO, of the message
stored in msg_iov to the socket endpoint.  The different ancillary
data types are described in <a href="#control_struct" class="auto internal xref">Section 4.3</a>.<a href="#section-4.1-6" class="pilcrow">¶</a></p>
<p id="section-4.1-7">On send side:<a href="#section-4.1-7" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.1-8.1">
            <p id="section-4.1-8.1.1">The flags parameter in sendmsg() can be set to:<a href="#section-4.1-8.1.1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.1-8.1.2.1">MSG_MORE: Indicates that data will be held until the next data is
  sent without this flag.<a href="#section-4.1-8.1.2.1" class="pilcrow">¶</a>
</li>
              <li class="normal" id="section-4.1-8.1.2.2">MSG_DONTWAIT:  Prevents blocking if there is no send buffer.<a href="#section-4.1-8.1.2.2" class="pilcrow">¶</a>
</li>
              <li class="normal" id="section-4.1-8.1.2.3">MSG_DATAGRAM:  Sends data as an unreliable datagram.<a href="#section-4.1-8.1.2.3" class="pilcrow">¶</a>
</li>
            </ul>
<p id="section-4.1-8.1.3">Additionally, the flags can also be set to the values in stream_flags
  on send side <a href="#struct_stream" class="auto internal xref">Section 4.3.1</a> if Stream msg_control is not
  being used. In this case, the most recently opened stream will be used
  for sending data.<a href="#section-4.1-8.1.3" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-4.1-8.2">
            <p id="section-4.1-8.2.1">msg_flags of msghdr passed to the kernel is ignored.<a href="#section-4.1-8.2.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="section-4.1-9">On receive side:<a href="#section-4.1-9" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.1-10.1">
            <p id="section-4.1-10.1.1">The flags parameter in recvmsg() might be set to:<a href="#section-4.1-10.1.1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.1-10.1.2.1">MSG_DONTWAIT:  Prevents blocking if there is no data in recv
  buffer.<a href="#section-4.1-10.1.2.1" class="pilcrow">¶</a>
</li>
            </ul>
</li>
          <li class="normal" id="section-4.1-10.2">
            <p id="section-4.1-10.2.1">msg_flags of msghdr returned from the kernel might be set to:<a href="#section-4.1-10.2.1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.1-10.2.2.1">MSG_DATAGRAM:  Indicates that the received data is a datagram.<a href="#section-4.1-10.2.2.1" class="pilcrow">¶</a>
</li>
              <li class="normal" id="section-4.1-10.2.2.2">MSG_NOTIFICATION:  Indicates that the received data is a notification
  message.<a href="#section-4.1-10.2.2.2" class="pilcrow">¶</a>
</li>
              <li class="normal" id="section-4.1-10.2.2.3">These flags might also be set to the values in
  stream_flags on receive side <a href="#struct_stream" class="auto internal xref">Section 4.3.1</a> if Stream
  msg_control is not being used. In this case, the stream id for received
  data is invisible to user space.<a href="#section-4.1-10.2.2.3" class="pilcrow">¶</a>
</li>
            </ul>
<p id="section-4.1-10.2.3">Additionally, the flags might also be set to the values in
  stream_flags on receive side <a href="#struct_stream" class="auto internal xref">Section 4.3.1</a> if Stream
  msg_control is not being used. In this case, the stream ID for received
  data is not visible to users.<a href="#section-4.1-10.2.3" class="pilcrow">¶</a></p>
</li>
        </ul>
</section>
</div>
<section id="section-4.2">
        <h3 id="name-ancillary-data-consideratio">
<a href="#section-4.2" class="section-number selfRef">4.2. </a><a href="#name-ancillary-data-consideratio" class="section-name selfRef">Ancillary Data Considerations and Semantics</a>
        </h3>
<p id="section-4.2-1">Programming with ancillary socket data (msg_control) contains some
subtleties and pitfalls, which are discussed below.<a href="#section-4.2-1" class="pilcrow">¶</a></p>
<section id="section-4.2.1">
          <h4 id="name-multiple-items-and-ordering">
<a href="#section-4.2.1" class="section-number selfRef">4.2.1. </a><a href="#name-multiple-items-and-ordering" class="section-name selfRef">Multiple Items and Ordering</a>
          </h4>
<p id="section-4.2.1-1">Multiple ancillary data items MAY be included in any call to sendmsg()
or recvmsg(). These MAY include QUIC-specific items, non-QUIC items (such
as IP-level items), or both. The ordering of ancillary data items, whether
QUIC-related or from another protocol, is implementation-dependent and not
significant. Therefore, applications MUST NOT rely on any specific
ordering.<a href="#section-4.2.1-1" class="pilcrow">¶</a></p>
<p id="section-4.2.1-2">QUIC_STREAM_INFO and QUIC_HANDSHAKE_INFO type ancillary data always
correspond to the data in the msghdr's msg_iov member. Only one such type
of ancillary data is allowed per sendmsg() or recvmsg() call.<a href="#section-4.2.1-2" class="pilcrow">¶</a></p>
</section>
<section id="section-4.2.2">
          <h4 id="name-accessing-and-manipulating-">
<a href="#section-4.2.2" class="section-number selfRef">4.2.2. </a><a href="#name-accessing-and-manipulating-" class="section-name selfRef">Accessing and Manipulating Ancillary Data</a>
          </h4>
<p id="section-4.2.2-1">Applications can infer the presence of data or ancillary data by
examining the msg_iovlen and msg_controllen msghdr members,
respectively<a href="#section-4.2.2-1" class="pilcrow">¶</a></p>
<p id="section-4.2.2-2">Implementations MAY have different padding requirements for ancillary
data, so portable applications SHOULD make use of the macros
CMSG_FIRSTHDR, CMSG_NXTHDR, CMSG_DATA, CMSG_SPACE, and CMSG_LEN.  See
<span>[<a href="#RFC3542" class="cite xref">RFC3542</a>]</span> for more information. The following is an example,
from <span>[<a href="#RFC3542" class="cite xref">RFC3542</a>]</span>, demonstrating the use of these macros to
access ancillary data<a href="#section-4.2.2-2" class="pilcrow">¶</a></p>
<div class="C lang-language sourcecode" id="section-4.2.2-3">
<pre>
struct msghdr msg;
struct cmsghdr *cmsgptr;

/* fill in msg */

/* call recvmsg() */

for (cmsgptr = CMSG_FIRSTHDR(&amp;msg); cmsgptr != NULL;
     cmsgptr = CMSG_NXTHDR(&amp;msg, cmsgptr)) {
  if (cmsgptr-&gt;cmsg_len == 0) {
     /* Error handling */
     break;
  }
  if (cmsgptr-&gt;cmsg_level == ... &amp;&amp; cmsgptr-&gt;cmsg_type == ... ) {
    u_char  *ptr;

    ptr = CMSG_DATA(cmsgptr);
    /* process data pointed to by ptr */
  }
}
</pre><a href="#section-4.2.2-3" class="pilcrow">¶</a>
</div>
</section>
<section id="section-4.2.3">
          <h4 id="name-control-message-buffer-sizi">
<a href="#section-4.2.3" class="section-number selfRef">4.2.3. </a><a href="#name-control-message-buffer-sizi" class="section-name selfRef">Control Message Buffer Sizing</a>
          </h4>
<p id="section-4.2.3-1">The information conveyed via QUIC_STREAM_INFO and QUIC_HANDSHAKE_INFO
ancillary data will often be fundamental to the correct and sane
operation of the sockets application. For example, if an application
needs to send and receive data on different QUIC streams, QUIC_STREAM_INFO
ancillary data is indispensable.<a href="#section-4.2.3-1" class="pilcrow">¶</a></p>
<p id="section-4.2.3-2">Given that some ancillary data is critical, and that multiple
ancillary data items MAY appear in any order, applications SHOULD be
carefully written to always provide a large enough buffer to contain
all possible ancillary data that can be presented by recvmsg().  If
the buffer is too small, and crucial data is truncated, it MAY pose a
fatal error condition.<a href="#section-4.2.3-2" class="pilcrow">¶</a></p>
<p id="section-4.2.3-3">Thus, it is essential that applications be able to deterministically
calculate the maximum required buffer size to pass to recvmsg().  One
constraint imposed on this specification that makes this possible is
that all ancillary data definitions are of a fixed length.  One way
to calculate the maximum required buffer size might be to take the
sum of the sizes of all enabled ancillary data item structures, as
calculated by CMSG_SPACE.  For example, if we enabled QUIC_STREAM_INFO
and IPV6_RECVPKTINFO <span>[<a href="#RFC3542" class="cite xref">RFC3542</a>]</span>, we would calculate and
allocate the buffer size as follows<a href="#section-4.2.3-3" class="pilcrow">¶</a></p>
<div class="C lang-language sourcecode" id="section-4.2.3-4">
<pre>
size_t total;
void *buf;

total = CMSG_SPACE(sizeof(struct quic_stream_info)) +
        CMSG_SPACE(sizeof(struct in6_pktinfo));

buf = malloc(total);
</pre><a href="#section-4.2.3-4" class="pilcrow">¶</a>
</div>
<p id="section-4.2.3-5">We could then use this buffer (buf) for msg_control on each call to
recvmsg() and be assured that we would not lose any ancillary data to
truncation.<a href="#section-4.2.3-5" class="pilcrow">¶</a></p>
</section>
</section>
<div id="control_struct">
<section id="section-4.3">
        <h3 id="name-quic-msg_control-structures">
<a href="#section-4.3" class="section-number selfRef">4.3. </a><a href="#name-quic-msg_control-structures" class="section-name selfRef">QUIC msg_control Structures</a>
        </h3>
<div id="struct_stream">
<section id="section-4.3.1">
          <h4 id="name-stream-information">
<a href="#section-4.3.1" class="section-number selfRef">4.3.1. </a><a href="#name-stream-information" class="section-name selfRef">Stream Information</a>
          </h4>
<p id="section-4.3.1-1">This control message (cmsg) specifies QUIC stream options for sendmsg()
and describes QUIC stream information about a received message via
recvmsg(). It uses struct quic_stream_info<a href="#section-4.3.1-1" class="pilcrow">¶</a></p>
<div class="C lang-language sourcecode" id="section-4.3.1-2">
<pre>
struct quic_stream_info {
  uint64_t stream_id;
  uint32_t stream_flags;
};
</pre><a href="#section-4.3.1-2" class="pilcrow">¶</a>
</div>
<p id="section-4.3.1-3">On send side:<a href="#section-4.3.1-3" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.3.1-4.1">
              <p id="section-4.3.1-4.1.1">stream_id:<a href="#section-4.3.1-4.1.1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.3.1-4.1.2.1">
                  <p id="section-4.3.1-4.1.2.1.1">-1:<a href="#section-4.3.1-4.1.2.1.1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.3.1-4.1.2.1.2.1">If MSG_STREAM_NEW is set: Open the next bidirectional stream and
    uses it for sending data.<a href="#section-4.3.1-4.1.2.1.2.1" class="pilcrow">¶</a>
</li>
                    <li class="normal" id="section-4.3.1-4.1.2.1.2.2">If both MSG_STREAM_NEW and MSG_STREAM_UNI are set: Opens the next
    unidirectional stream and uses it for sending data.<a href="#section-4.3.1-4.1.2.1.2.2" class="pilcrow">¶</a>
</li>
                    <li class="normal" id="section-4.3.1-4.1.2.1.2.3">Otherwise: Use the latest opened stream for sending data.<a href="#section-4.3.1-4.1.2.1.2.3" class="pilcrow">¶</a>
</li>
                  </ul>
</li>
                <li class="normal" id="section-4.3.1-4.1.2.2">
                  <p id="section-4.3.1-4.1.2.2.1">!-1: The specified stream ID is used with the 1st 2 bits:<a href="#section-4.3.1-4.1.2.2.1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.3.1-4.1.2.2.2.1">QUIC_STREAM_TYPE_SERVER_MASK(0x1): Indicates if it is a server-side
    stream.<a href="#section-4.3.1-4.1.2.2.2.1" class="pilcrow">¶</a>
</li>
                    <li class="normal" id="section-4.3.1-4.1.2.2.2.2">QUIC_STREAM_TYPE_UNI_MASK(0x2): Indicates if it is a unidirectional
    stream.<a href="#section-4.3.1-4.1.2.2.2.2" class="pilcrow">¶</a>
</li>
                  </ul>
</li>
              </ul>
</li>
            <li class="normal" id="section-4.3.1-4.2">
              <p id="section-4.3.1-4.2.1">stream_flags:<a href="#section-4.3.1-4.2.1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.3.1-4.2.2.1">MSG_STREAM_NEW: Open a stream and send the first data.<a href="#section-4.3.1-4.2.2.1" class="pilcrow">¶</a>
</li>
                <li class="normal" id="section-4.3.1-4.2.2.2">MSG_STREAM_FIN: Send the last data and close the stream.<a href="#section-4.3.1-4.2.2.2" class="pilcrow">¶</a>
</li>
                <li class="normal" id="section-4.3.1-4.2.2.3">MSG_STREAM_UNI: Open the next unidirectional stream.<a href="#section-4.3.1-4.2.2.3" class="pilcrow">¶</a>
</li>
                <li class="normal" id="section-4.3.1-4.2.2.4">MSG_STREAM_DONTWAIT: Open the stream without blocking.<a href="#section-4.3.1-4.2.2.4" class="pilcrow">¶</a>
</li>
              </ul>
</li>
          </ul>
<p id="section-4.3.1-5">On receive side:<a href="#section-4.3.1-5" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.3.1-6.1">
              <p id="section-4.3.1-6.1.1">stream_id: Identifies the stream to which the received data
  belongs.<a href="#section-4.3.1-6.1.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-4.3.1-6.2">
              <p id="section-4.3.1-6.2.1">stream_flags:<a href="#section-4.3.1-6.2.1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.3.1-6.2.2.1">MSG_STREAM_FIN: Indicates that the data received is the last one for
  this stream.<a href="#section-4.3.1-6.2.2.1" class="pilcrow">¶</a>
</li>
              </ul>
</li>
          </ul>
<p id="section-4.3.1-7">This cmsg is specifically used for sending user stream data, including
early or 0-RTT data. When sending user unreliable datagrams, this cmsg
SHOULD NOT be set.<a href="#section-4.3.1-7" class="pilcrow">¶</a></p>
</section>
</div>
<div id="struct_handshake">
<section id="section-4.3.2">
          <h4 id="name-handshake-information">
<a href="#section-4.3.2" class="section-number selfRef">4.3.2. </a><a href="#name-handshake-information" class="section-name selfRef">Handshake Information</a>
          </h4>
<p id="section-4.3.2-1">This control message (cmsg) provides information for sending and
receiving handshake/TLS messages via sendmsg() or recvmsg(). It uses
struct quic_handshake_info<a href="#section-4.3.2-1" class="pilcrow">¶</a></p>
<div class="C lang-language sourcecode" id="section-4.3.2-2">
<pre>
struct quic_handshake_info {
  uint8_t crypto_level;
};
</pre><a href="#section-4.3.2-2" class="pilcrow">¶</a>
</div>
<p id="section-4.3.2-3">crypto_level: Specifies the level of data:<a href="#section-4.3.2-3" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.3.2-4.1">QUIC_CRYPTO_APP: Resumption ticket data.<a href="#section-4.3.2-4.1" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-4.3.2-4.2">QUIC_CRYPTO_INITIAL: Initial level data.<a href="#section-4.3.2-4.2" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-4.3.2-4.3">QUIC_CRYPTO_HANDSHAKE: Handshake level data.<a href="#section-4.3.2-4.3" class="pilcrow">¶</a>
</li>
          </ul>
<p id="section-4.3.2-5">This cmsg is used only during the handshake process.<a href="#section-4.3.2-5" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
</section>
</div>
<section id="section-5">
      <h2 id="name-quic-events-and-notificatio">
<a href="#section-5" class="section-number selfRef">5. </a><a href="#name-quic-events-and-notificatio" class="section-name selfRef">QUIC Events and Notifications</a>
      </h2>
<p id="section-5-1">A QUIC application MAY need to understand and process events and errors
that occur within the QUIC stack, such as stream updates, max_stream
changes, connection close, connection migration, key updates and new
tokens. These events are categorized under the quic_event_type enum:<a href="#section-5-1" class="pilcrow">¶</a></p>
<div class="C lang-language sourcecode" id="section-5-2">
<pre>
enum quic_event_type {
  QUIC_EVENT_NONE,
  QUIC_EVENT_STREAM_UPDATE,
  QUIC_EVENT_STREAM_MAX_STREAM,
  QUIC_EVENT_CONNECTION_CLOSE,
  QUIC_EVENT_CONNECTION_MIGRATION,
  QUIC_EVENT_KEY_UPDATE,
  QUIC_EVENT_NEW_TOKEN,
};
</pre><a href="#section-5-2" class="pilcrow">¶</a>
</div>
<p id="section-5-3">When a notification arrives, recvmsg() returns the notification in the
application-supplied data buffer via msg_iov, and sets MSG_NOTIFICATION
in msg_flags of msghdr in <a href="#struct_stream" class="auto internal xref">Section 4.3.1</a>.<a href="#section-5-3" class="pilcrow">¶</a></p>
<p id="section-5-4">The first byte of the received data indicates the type of the event,
corresponding to one of the values in the quic_event_type enum. The
subsequent bytes contain the content of the event, meaning the length of
the content is the total data length minus one byte. To manage and enable
these events, refer to socket option EVENT
<a href="#sockopt_event" class="auto internal xref">Section 5.2.1</a>.<a href="#section-5-4" class="pilcrow">¶</a></p>
<div id="notification">
<section id="section-5.1">
        <h3 id="name-quic-notification-structure">
<a href="#section-5.1" class="section-number selfRef">5.1. </a><a href="#name-quic-notification-structure" class="section-name selfRef">QUIC Notification Structure</a>
        </h3>
<section id="section-5.1.1">
          <h4 id="name-quic_event_stream_update">
<a href="#section-5.1.1" class="section-number selfRef">5.1.1. </a><a href="#name-quic_event_stream_update" class="section-name selfRef">QUIC_EVENT_STREAM_UPDATE</a>
          </h4>
<p id="section-5.1.1-1">Only notifications with one of the following states are delivered to
userspace:<a href="#section-5.1.1-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-5.1.1-2.1">
              <p id="section-5.1.1-2.1.1">QUIC_STREAM_SEND_STATE_RECVD<a href="#section-5.1.1-2.1.1" class="pilcrow">¶</a></p>
<p id="section-5.1.1-2.1.2">An update is delivered when all data on the stream has been
  acknowledged. This indicates that the peer has confirmed receipt of
  all sent data for this stream.<a href="#section-5.1.1-2.1.2" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-5.1.1-2.2">
              <p id="section-5.1.1-2.2.1">QUIC_STREAM_SEND_STATE_RESET_SENT<a href="#section-5.1.1-2.2.1" class="pilcrow">¶</a></p>
<p id="section-5.1.1-2.2.2">An update is delivered only if a STOP_SENDING frame is received from
  the peer and a STREAM_RESET frame is trigger to send out. The
  STOP_SENDING frame MAY be sent by the peer via socket option
  STREAM_STOP_SENDING <a href="#sockopt_stream_stop_sending" class="auto internal xref">Section 6.3.2</a>.<a href="#section-5.1.1-2.2.2" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-5.1.1-2.3">
              <p id="section-5.1.1-2.3.1">QUIC_STREAM_SEND_STATE_RESET_RECVD<a href="#section-5.1.1-2.3.1" class="pilcrow">¶</a></p>
<p id="section-5.1.1-2.3.2">An update is delivered when a STREAM_RESET frame has been received and
  acknowledged by the peer. The STREAM_RESET frame MAY be sent via socket
  option STREAM_RESET <a href="#sockopt_stream_reset" class="auto internal xref">Section 6.3.1</a>.<a href="#section-5.1.1-2.3.2" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-5.1.1-2.4">
              <p id="section-5.1.1-2.4.1">QUIC_STREAM_RECV_STATE_RECV<a href="#section-5.1.1-2.4.1" class="pilcrow">¶</a></p>
<p id="section-5.1.1-2.4.2">An update is delivered only when the last fragment of data has not
  yet arrived. This event is sent to inform the application that there is
  pending data for the stream.<a href="#section-5.1.1-2.4.2" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-5.1.1-2.5">
              <p id="section-5.1.1-2.5.1">QUIC_STREAM_RECV_STATE_SIZE_KNOWN<a href="#section-5.1.1-2.5.1" class="pilcrow">¶</a></p>
<p id="section-5.1.1-2.5.2"> An update is delivered only if data arrives out of order. This
  indicates that the size of the data is known, even though the fragments
  are not in sequential order.<a href="#section-5.1.1-2.5.2" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-5.1.1-2.6">
              <p id="section-5.1.1-2.6.1">QUIC_STREAM_RECV_STATE_RECVD<a href="#section-5.1.1-2.6.1" class="pilcrow">¶</a></p>
<p id="section-5.1.1-2.6.2">An update is delivered when all data on the stream has been fully
  received. This signifies that the application has received the complete
  data for the stream.<a href="#section-5.1.1-2.6.2" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-5.1.1-2.7">
              <p id="section-5.1.1-2.7.1">QUIC_STREAM_RECV_STATE_RESET_RECVD<a href="#section-5.1.1-2.7.1" class="pilcrow">¶</a></p>
<p id="section-5.1.1-2.7.2"> An update is delivered when a STREAM_RESET frame is received. This
  indicates that the peer has reset the stream, and further data SHOULD
  NOT be expected.<a href="#section-5.1.1-2.7.2" class="pilcrow">¶</a></p>
</li>
          </ul>
<p id="section-5.1.1-3">Data format in the event<a href="#section-5.1.1-3" class="pilcrow">¶</a></p>
<div class="C lang-language sourcecode" id="section-5.1.1-4">
<pre>
struct quic_stream_update {
  uint64_t id;
  uint32_t state;
  uint32_t errcode;
  uint64_t finalsz;
};
</pre><a href="#section-5.1.1-4" class="pilcrow">¶</a>
</div>
</section>
<section id="section-5.1.2">
          <h4 id="name-quic_event_stream_max_strea">
<a href="#section-5.1.2" class="section-number selfRef">5.1.2. </a><a href="#name-quic_event_stream_max_strea" class="section-name selfRef">QUIC_EVENT_STREAM_MAX_STREAM</a>
          </h4>
<p id="section-5.1.2-1">This notification is delivered when a MAX_STREAMS frame is received. It
is particularly useful when using MSG_STREAM_DONTWAIT stream_flags to open
a stream via socket option STREAM_OPEN <a href="#sockopt_stream_open" class="auto internal xref">Section 6.2.1</a>
whose ID exceeds the current maximum stream count. After receiving this
notification, the application SHOULD attempt to open the stream again.<a href="#section-5.1.2-1" class="pilcrow">¶</a></p>
<p id="section-5.1.2-2">Data format in the event<a href="#section-5.1.2-2" class="pilcrow">¶</a></p>
<div class="C lang-language sourcecode" id="section-5.1.2-3">
<pre>
uint64_t max_stream;
</pre><a href="#section-5.1.2-3" class="pilcrow">¶</a>
</div>
</section>
<section id="section-5.1.3">
          <h4 id="name-quic_event_connection_close">
<a href="#section-5.1.3" class="section-number selfRef">5.1.3. </a><a href="#name-quic_event_connection_close" class="section-name selfRef">QUIC_EVENT_CONNECTION_CLOSE</a>
          </h4>
<p id="section-5.1.3-1">This notification is delivered when a CLOSE frame is received from the
peer. The peer MAY set the close information via socket option
CONNECTION_CLOSE <a href="#sockopt_close" class="auto internal xref">Section 6.1.2</a> before calling close().<a href="#section-5.1.3-1" class="pilcrow">¶</a></p>
<p id="section-5.1.3-2">Data format in the event<a href="#section-5.1.3-2" class="pilcrow">¶</a></p>
<div class="C lang-language sourcecode" id="section-5.1.3-3">
<pre>
struct quic_connection_close {
  uint32_t errcode;
  uint8_t frame;
  uint8_t phrase[];
};
</pre><a href="#section-5.1.3-3" class="pilcrow">¶</a>
</div>
</section>
<section id="section-5.1.4">
          <h4 id="name-quic_event_connection_migra">
<a href="#section-5.1.4" class="section-number selfRef">5.1.4. </a><a href="#name-quic_event_connection_migra" class="section-name selfRef">QUIC_EVENT_CONNECTION_MIGRATION</a>
          </h4>
<p id="section-5.1.4-1">This notification is delivered when either side successfully changes its
source address using the socket option CONNECTION_MIGRATION
<a href="#sockopt_migration" class="auto internal xref">Section 6.3.3</a>, or when the destination address is
changed by the peer's connection migration. The notification includes a
parameter indicating whether the migration was local or initiated by the
peer. After receiving this notification, the new address can be retrieved
using getsockname() for the local address or getpeername() for the peer's
address.<a href="#section-5.1.4-1" class="pilcrow">¶</a></p>
<p id="section-5.1.4-2">Data format in the event<a href="#section-5.1.4-2" class="pilcrow">¶</a></p>
<div class="C lang-language sourcecode" id="section-5.1.4-3">
<pre>
uint8_t local_migration;
</pre><a href="#section-5.1.4-3" class="pilcrow">¶</a>
</div>
</section>
<section id="section-5.1.5">
          <h4 id="name-quic_event_key_update">
<a href="#section-5.1.5" class="section-number selfRef">5.1.5. </a><a href="#name-quic_event_key_update" class="section-name selfRef">QUIC_EVENT_KEY_UPDATE</a>
          </h4>
<p id="section-5.1.5-1">This notification is delivered when both sides have successfully updated
to the new key phase after a key update via socket option KEY_UPDATE
<a href="#sockopt_key_update" class="auto internal xref">Section 6.3.4</a> on either side. The parameter
indicates which key phase is currently in use.<a href="#section-5.1.5-1" class="pilcrow">¶</a></p>
<p id="section-5.1.5-2">Data format in the event<a href="#section-5.1.5-2" class="pilcrow">¶</a></p>
<div class="C lang-language sourcecode" id="section-5.1.5-3">
<pre>
uint8_t key_update_phase;
</pre><a href="#section-5.1.5-3" class="pilcrow">¶</a>
</div>
</section>
<div id="event_new_token">
<section id="section-5.1.6">
          <h4 id="name-quic_event_new_token">
<a href="#section-5.1.6" class="section-number selfRef">5.1.6. </a><a href="#name-quic_event_new_token" class="section-name selfRef">QUIC_EVENT_NEW_TOKEN</a>
          </h4>
<p id="section-5.1.6-1">This notification is delivered whenever a NEW_TOKEN frame is received
from the peer. Since the handshake occurs in userspace, you can send these
tokens using socket option TOKEN <a href="#sockopt_new_token" class="auto internal xref">Section 6.1.4</a>.<a href="#section-5.1.6-1" class="pilcrow">¶</a></p>
<p id="section-5.1.6-2">Data format in the event<a href="#section-5.1.6-2" class="pilcrow">¶</a></p>
<div class="C lang-language sourcecode" id="section-5.1.6-3">
<pre>
uint8_t *token;
</pre><a href="#section-5.1.6-3" class="pilcrow">¶</a>
</div>
</section>
</div>
</section>
</div>
<section id="section-5.2">
        <h3 id="name-notification-interest-optio">
<a href="#section-5.2" class="section-number selfRef">5.2. </a><a href="#name-notification-interest-optio" class="section-name selfRef">Notification Interest Options</a>
        </h3>
<div id="sockopt_event">
<section id="section-5.2.1">
          <h4 id="name-quic_sockopt_event-option">
<a href="#section-5.2.1" class="section-number selfRef">5.2.1. </a><a href="#name-quic_sockopt_event-option" class="section-name selfRef">QUIC_SOCKOPT_EVENT Option</a>
          </h4>
<p id="section-5.2.1-1">This option is used to enable or disable a specific type of event or
notification.<a href="#section-5.2.1-1" class="pilcrow">¶</a></p>
<p id="section-5.2.1-2">The optval type is<a href="#section-5.2.1-2" class="pilcrow">¶</a></p>
<div class="C lang-language sourcecode" id="section-5.2.1-3">
<pre>
struct quic_event_option {
  uint8_t type;
  uint8_t on;
};
</pre><a href="#section-5.2.1-3" class="pilcrow">¶</a>
</div>
<p id="section-5.2.1-4">type: Specifies the event type, as defined in
<a href="#notification" class="auto internal xref">Section 5.1</a>.<a href="#section-5.2.1-4" class="pilcrow">¶</a></p>
<p id="section-5.2.1-5">on: Indicates whether the event is enabled or disabled:<a href="#section-5.2.1-5" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-5.2.1-6.1">0: disable.<a href="#section-5.2.1-6.1" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-5.2.1-6.2">!0: enable.<a href="#section-5.2.1-6.2" class="pilcrow">¶</a>
</li>
          </ul>
<p id="section-5.2.1-7">By default, all events are disabled.<a href="#section-5.2.1-7" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</section>
<div id="sockopt">
<section id="section-6">
      <h2 id="name-socket-options">
<a href="#section-6" class="section-number selfRef">6. </a><a href="#name-socket-options" class="section-name selfRef">Socket Options</a>
      </h2>
<section id="section-6.1">
        <h3 id="name-read-write-options">
<a href="#section-6.1" class="section-number selfRef">6.1. </a><a href="#name-read-write-options" class="section-name selfRef">Read/Write Options</a>
        </h3>
<section id="section-6.1.1">
          <h4 id="name-quic_sockopt_event">
<a href="#section-6.1.1" class="section-number selfRef">6.1.1. </a><a href="#name-quic_sockopt_event" class="section-name selfRef">QUIC_SOCKOPT_EVENT</a>
          </h4>
<p id="section-6.1.1-1">This socket option is used to set a specific notification option.
For a detailed description of this option and its usage, please refer
to <a href="#sockopt_event" class="auto internal xref">Section 5.2.1</a>.<a href="#section-6.1.1-1" class="pilcrow">¶</a></p>
</section>
<div id="sockopt_close">
<section id="section-6.1.2">
          <h4 id="name-quic_sockopt_connection_clo">
<a href="#section-6.1.2" class="section-number selfRef">6.1.2. </a><a href="#name-quic_sockopt_connection_clo" class="section-name selfRef">QUIC_SOCKOPT_CONNECTION_CLOSE</a>
          </h4>
<p id="section-6.1.2-1">This option is used to get or get the close context, which includes
errcode and phrase and frame. On close side, set it before calling close()
to tell the peer the closing info, while on being closed side get it to
show the peer closing info.<a href="#section-6.1.2-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-6.1.2-2.1">On the closing side: Set this option before calling close() to
communicate the closing information to the peer.<a href="#section-6.1.2-2.1" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-6.1.2-2.2">On the receiving side: Get this option to retrieve the closing
information from the peer.<a href="#section-6.1.2-2.2" class="pilcrow">¶</a>
</li>
          </ul>
<p id="section-6.1.2-3">The optval type is<a href="#section-6.1.2-3" class="pilcrow">¶</a></p>
<div class="C lang-language sourcecode" id="section-6.1.2-4">
<pre>
struct quic_connection_close {
  uint32_t errcode;
  uint8_t frame;
  uint8_t phrase[];
};
</pre><a href="#section-6.1.2-4" class="pilcrow">¶</a>
</div>
<ul class="normal">
<li class="normal" id="section-6.1.2-5.1">errcode: Error code for the application protocol. Defaults to 0.<a href="#section-6.1.2-5.1" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-6.1.2-5.2">phrase: Optional string for additional details. Defaults to null.<a href="#section-6.1.2-5.2" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-6.1.2-5.3">frame: Frame type that caused the closure. Defaults to 0.<a href="#section-6.1.2-5.3" class="pilcrow">¶</a>
</li>
          </ul>
</section>
</div>
<div id="sockopt_transport_param">
<section id="section-6.1.3">
          <h4 id="name-quic_sockopt_transport_para">
<a href="#section-6.1.3" class="section-number selfRef">6.1.3. </a><a href="#name-quic_sockopt_transport_para" class="section-name selfRef">QUIC_SOCKOPT_TRANSPORT_PARAM</a>
          </h4>
<p id="section-6.1.3-1">This option is used to configure transport parameters, including both
the original QUIC transport parameters and some handshake-specific
options.<a href="#section-6.1.3-1" class="pilcrow">¶</a></p>
<p id="section-6.1.3-2">The optval type is<a href="#section-6.1.3-2" class="pilcrow">¶</a></p>
<div class="C lang-language sourcecode" id="section-6.1.3-3">
<pre>
struct quic_transport_param {
  uint8_t     remote;

  uint8_t     disable_active_migration; // 0 by default
  uint8_t     grease_quic_bit; // 0
  uint8_t     stateless_reset; // 0
  uint8_t     disable_1rtt_encryption; // 0
  uint8_t     disable_compatible_version; // 0
  uint64_t    max_udp_payload_size; // 65527
  uint64_t    ack_delay_exponent; // 3
  uint64_t    max_ack_delay; // 25000
  uint64_t    active_connection_id_limit; // 7
  uint64_t    max_idle_timeout; // 30000000 us
  uint64_t    max_datagram_frame_size; // 0
  uint64_t    max_data; // 65536 * 32
  uint64_t    max_stream_data_bidi_local; // 65536 * 4
  uint64_t    max_stream_data_bidi_remote; // 65536 * 4
  uint64_t    max_stream_data_uni; // 65536 * 4
  uint64_t    max_streams_bidi; // 100
  uint64_t    max_streams_uni; // 100
  uint64_t    initial_smoothed_rtt; // 333000

  uint32_t    plpmtud_probe_timeout; // 0 (in usec)
  uint8_t     validate_peer_address; // 0
  uint8_t     receive_session_ticket; // 0
  uint8_t     certificate_request; // 0
  uint8_t     congestion_control_alg; // QUIC_CONG_ALG_RENO
  uint32_t    payload_cipher_type; // 0
  uint32_t    version; // QUIC_VERSION_V1
};
</pre><a href="#section-6.1.3-3" class="pilcrow">¶</a>
</div>
<p id="section-6.1.3-4">Transport Parameters from <span>[<a href="#RFC9000" class="cite xref">RFC9000</a>]</span>:<a href="#section-6.1.3-4" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-6.1.3-5.1">max_udp_payload_size<a href="#section-6.1.3-5.1" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-6.1.3-5.2">ack_delay_exponent<a href="#section-6.1.3-5.2" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-6.1.3-5.3">max_ack_delay<a href="#section-6.1.3-5.3" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-6.1.3-5.4">active_connection_id_limit<a href="#section-6.1.3-5.4" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-6.1.3-5.5">max_idle_timeout<a href="#section-6.1.3-5.5" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-6.1.3-5.6">max_datagram_frame_size<a href="#section-6.1.3-5.6" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-6.1.3-5.7">max_data<a href="#section-6.1.3-5.7" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-6.1.3-5.8">max_stream_data_bidi_local<a href="#section-6.1.3-5.8" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-6.1.3-5.9">max_stream_data_bidi_remote<a href="#section-6.1.3-5.9" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-6.1.3-5.10">max_stream_data_uni<a href="#section-6.1.3-5.10" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-6.1.3-5.11">max_streams_bidi<a href="#section-6.1.3-5.11" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-6.1.3-5.12">max_streams_uni<a href="#section-6.1.3-5.12" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-6.1.3-5.13">initial_smoothed_rtt<a href="#section-6.1.3-5.13" class="pilcrow">¶</a>
</li>
          </ul>
<p id="section-6.1.3-6">Handshake Options:<a href="#section-6.1.3-6" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-6.1.3-7.1">
              <p id="section-6.1.3-7.1.1">plpmtud_probe_timeout (in usec):<a href="#section-6.1.3-7.1.1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-6.1.3-7.1.2.1">0 to disable<a href="#section-6.1.3-7.1.2.1" class="pilcrow">¶</a>
</li>
                <li class="normal" id="section-6.1.3-7.1.2.2">at least QUIC_MIN_PROBE_TIMEOUT (5000000)<a href="#section-6.1.3-7.1.2.2" class="pilcrow">¶</a>
</li>
              </ul>
</li>
            <li class="normal" id="section-6.1.3-7.2">
              <p id="section-6.1.3-7.2.1">validate_peer_address: Server-side only:<a href="#section-6.1.3-7.2.1" class="pilcrow">¶</a></p>
<p id="section-6.1.3-7.2.2">If this option is enabled, server will send a retry packet to client
upon receiving the first handshake request. This serves to validate
client's IP address, ensuring it is legitimate and reachable before
proceeding with the rest of the handshake.<a href="#section-6.1.3-7.2.2" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-6.1.3-7.3">
              <p id="section-6.1.3-7.3.1">receive_session_ticket: Client-side only:<a href="#section-6.1.3-7.3.1" class="pilcrow">¶</a></p>
<p id="section-6.1.3-7.3.2">If this option is enabled, client will not deliver user data to
userspace until TLS session ticket message is received. This ensures
userspace handshake to complete with TLS session ticket message processed
and resumption ticket set back to kernel before kernel consumers receives
any user data. If this option is not set, TLS session ticket message will
be dropped.<a href="#section-6.1.3-7.3.2" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-6.1.3-7.4">
              <p id="section-6.1.3-7.4.1">certificate_request: Server-side only, options include:<a href="#section-6.1.3-7.4.1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-6.1.3-7.4.2.1">0: IGNORE<a href="#section-6.1.3-7.4.2.1" class="pilcrow">¶</a>
</li>
                <li class="normal" id="section-6.1.3-7.4.2.2">1: REQUEST<a href="#section-6.1.3-7.4.2.2" class="pilcrow">¶</a>
</li>
                <li class="normal" id="section-6.1.3-7.4.2.3">2: REQUIRE<a href="#section-6.1.3-7.4.2.3" class="pilcrow">¶</a>
</li>
              </ul>
</li>
            <li class="normal" id="section-6.1.3-7.5">
              <p id="section-6.1.3-7.5.1">congestion_control_alg: Congestion control algorithm,
options MAY include:<a href="#section-6.1.3-7.5.1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-6.1.3-7.5.2.1">NEW_RENO<a href="#section-6.1.3-7.5.2.1" class="pilcrow">¶</a>
</li>
                <li class="normal" id="section-6.1.3-7.5.2.2">CUBIC<a href="#section-6.1.3-7.5.2.2" class="pilcrow">¶</a>
</li>
                <li class="normal" id="section-6.1.3-7.5.2.3">BBR<a href="#section-6.1.3-7.5.2.3" class="pilcrow">¶</a>
</li>
              </ul>
</li>
            <li class="normal" id="section-6.1.3-7.6">
              <p id="section-6.1.3-7.6.1">payload_cipher_type: Cipher type for payload encryption,
options include:<a href="#section-6.1.3-7.6.1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-6.1.3-7.6.2.1">AES_GCM_128<a href="#section-6.1.3-7.6.2.1" class="pilcrow">¶</a>
</li>
                <li class="normal" id="section-6.1.3-7.6.2.2">AES_GCM_256<a href="#section-6.1.3-7.6.2.2" class="pilcrow">¶</a>
</li>
                <li class="normal" id="section-6.1.3-7.6.2.3">AES_CCM_128<a href="#section-6.1.3-7.6.2.3" class="pilcrow">¶</a>
</li>
                <li class="normal" id="section-6.1.3-7.6.2.4">CHACHA20_POLY1305<a href="#section-6.1.3-7.6.2.4" class="pilcrow">¶</a>
</li>
              </ul>
</li>
            <li class="normal" id="section-6.1.3-7.7">
              <p id="section-6.1.3-7.7.1">version: QUIC version, options include:<a href="#section-6.1.3-7.7.1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-6.1.3-7.7.2.1">QUIC_VERSION_V1<a href="#section-6.1.3-7.7.2.1" class="pilcrow">¶</a>
</li>
                <li class="normal" id="section-6.1.3-7.7.2.2">QUIC_VERSION_V2<a href="#section-6.1.3-7.7.2.2" class="pilcrow">¶</a>
</li>
              </ul>
</li>
          </ul>
<p id="section-6.1.3-8">Others:<a href="#section-6.1.3-8" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-6.1.3-9.1">remote: Allows users to set remote transport parameters. Together with
the session resumption ticket, it is used to set the remote transport
parameters from the last connection before sending 0-RTT data.<a href="#section-6.1.3-9.1" class="pilcrow">¶</a>
</li>
          </ul>
<p id="section-6.1.3-10">All members have default values as specified in the struct code.<a href="#section-6.1.3-10" class="pilcrow">¶</a></p>
</section>
</div>
<div id="sockopt_new_token">
<section id="section-6.1.4">
          <h4 id="name-quic_sockopt_token">
<a href="#section-6.1.4" class="section-number selfRef">6.1.4. </a><a href="#name-quic_sockopt_token" class="section-name selfRef">QUIC_SOCKOPT_TOKEN</a>
          </h4>
<p id="section-6.1.4-1">This option is used to manage tokens for address verification in QUIC
connections. It behaves differently depending on whether it's being used
on the client side or the server side.<a href="#section-6.1.4-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-6.1.4-2.1">
              <p id="section-6.1.4-2.1.1">Client-Side Usage:<a href="#section-6.1.4-2.1.1" class="pilcrow">¶</a></p>
<p id="section-6.1.4-2.1.2">The client uses this option to set a token provided by the peer
  server. This token is typically issued by the server during the last
  connection and is used for address verification in subsequent
  connections.<a href="#section-6.1.4-2.1.2" class="pilcrow">¶</a></p>
<p id="section-6.1.4-2.1.3">The token can be obtained from the server during the previous
  connection, either via getsockopt() with this option or from event
  NEW_TOKEN <a href="#event_new_token" class="auto internal xref">Section 5.1.6</a>.<a href="#section-6.1.4-2.1.3" class="pilcrow">¶</a></p>
<p id="section-6.1.4-2.1.4">The optval type is<a href="#section-6.1.4-2.1.4" class="pilcrow">¶</a></p>
<div class="C lang-language sourcecode" id="section-6.1.4-2.1.5">
<pre>
  uint8_t *opt;
</pre><a href="#section-6.1.4-2.1.5" class="pilcrow">¶</a>
</div>
</li>
            <li class="normal" id="section-6.1.4-2.2">
              <p id="section-6.1.4-2.2.1">Server-Side Usage:<a href="#section-6.1.4-2.2.1" class="pilcrow">¶</a></p>
<p id="section-6.1.4-2.2.2">The server uses this option to issue a new token to the client. This
  token will be used by the client for address verification in the next
  connection.<a href="#section-6.1.4-2.2.2" class="pilcrow">¶</a></p>
<p id="section-6.1.4-2.2.3">The optval type is null.<a href="#section-6.1.4-2.2.3" class="pilcrow">¶</a></p>
</li>
          </ul>
<p id="section-6.1.4-3">The default value in socket is null.<a href="#section-6.1.4-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="sockopt_alpn">
<section id="section-6.1.5">
          <h4 id="name-quic_sockopt_alpn">
<a href="#section-6.1.5" class="section-number selfRef">6.1.5. </a><a href="#name-quic_sockopt_alpn" class="section-name selfRef">QUIC_SOCKOPT_ALPN</a>
          </h4>
<p id="section-6.1.5-1">This socket option is used to set or retrieve the ALPN identifiers
before or after a QUIC handshake. ALPN is critical for selecting the
protocol used over a QUIC connection, such as HTTP/3, SMB, or custom
protocols.<a href="#section-6.1.5-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-6.1.5-2.1">
              <p id="section-6.1.5-2.1.1">Client-Side Usage:<a href="#section-6.1.5-2.1.1" class="pilcrow">¶</a></p>
<p id="section-6.1.5-2.1.2">The client sets the desired ALPNs before the handshake. Multiple ALPNs
  can be specified, separated by commas (e.g., "smbd,h3,ksmbd").<a href="#section-6.1.5-2.1.2" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-6.1.5-2.2">
              <p id="section-6.1.5-2.2.1">Server-Side Usage:<a href="#section-6.1.5-2.2.1" class="pilcrow">¶</a></p>
<p id="section-6.1.5-2.2.2">On a listening socket if kernel supports ALPN matching, this feature
  directs incoming requests to the appropriate application based on ALPNs.
  The ALPNs MUST be set on the socket before calling listen() to enable
  this functionality.<a href="#section-6.1.5-2.2.2" class="pilcrow">¶</a></p>
<p id="section-6.1.5-2.2.3">On a accepting socket, the server sets the ALPNs it supports before
  the handshake begins, otherwise, it uses the ALPNs from the listening
  socket.<a href="#section-6.1.5-2.2.3" class="pilcrow">¶</a></p>
</li>
          </ul>
<p id="section-6.1.5-3">During the handshake process, both client and server retrieve the ALPNs
sent by the peer and attempt to match them with one of the ALPNs set on
the socket prior to the handshake.<a href="#section-6.1.5-3" class="pilcrow">¶</a></p>
<p id="section-6.1.5-4">Once a match is found, the matched ALPN is set on the socket after the
handshake is completed. This allows users to retrieve the selected ALPN via
the appropriate socket option, enabling the application to identify which
protocol has been successfully negotiated.<a href="#section-6.1.5-4" class="pilcrow">¶</a></p>
<p id="section-6.1.5-5">The optval type is<a href="#section-6.1.5-5" class="pilcrow">¶</a></p>
<div class="C lang-language sourcecode" id="section-6.1.5-6">
<pre>
char *alpn;
</pre><a href="#section-6.1.5-6" class="pilcrow">¶</a>
</div>
<p id="section-6.1.5-7">The default value in socket is null.<a href="#section-6.1.5-7" class="pilcrow">¶</a></p>
</section>
</div>
<div id="sockopt_session_ticket">
<section id="section-6.1.6">
          <h4 id="name-quic_sockopt_session_ticket">
<a href="#section-6.1.6" class="section-number selfRef">6.1.6. </a><a href="#name-quic_sockopt_session_ticket" class="section-name selfRef">QUIC_SOCKOPT_SESSION_TICKET</a>
          </h4>
<p id="section-6.1.6-1">This socket option is used to set a session resumption ticket on the
client side, enabling the client to resume a previously established QUIC
session with the server.<a href="#section-6.1.6-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-6.1.6-2.1">
              <p id="section-6.1.6-2.1.1">Client-Side Usage:<a href="#section-6.1.6-2.1.1" class="pilcrow">¶</a></p>
<p id="section-6.1.6-2.1.2">The client uses this option to set a session resumption ticket before
  initiating a new connection. The ticket, usually issued by the peer
  during the last connection, facilitates session resumption and helps
  to re-establish the connection more efficiently.<a href="#section-6.1.6-2.1.2" class="pilcrow">¶</a></p>
<p id="section-6.1.6-2.1.3">The ticket value is obtained from the previous connection, typically
  via the getsockopt call with this option.<a href="#section-6.1.6-2.1.3" class="pilcrow">¶</a></p>
<p id="section-6.1.6-2.1.4">The optval type is<a href="#section-6.1.6-2.1.4" class="pilcrow">¶</a></p>
<div class="C lang-language sourcecode" id="section-6.1.6-2.1.5">
<pre>
  uint8_t *opt;
</pre><a href="#section-6.1.6-2.1.5" class="pilcrow">¶</a>
</div>
<p id="section-6.1.6-2.1.6">See an example in <a href="#example_early" class="auto internal xref">Appendix B</a><a href="#section-6.1.6-2.1.6" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-6.1.6-2.2">
              <p id="section-6.1.6-2.2.1">Server-Side Usage:<a href="#section-6.1.6-2.2.1" class="pilcrow">¶</a></p>
<p id="section-6.1.6-2.2.2">The server does not use this option to set or process a session
  resumption ticket.<a href="#section-6.1.6-2.2.2" class="pilcrow">¶</a></p>
<p id="section-6.1.6-2.2.3">The session resumption ticket SHOULD be issued via sendmsg() with
  crypto_level QUIC_CRYPTO_APP in Handshake msg_control
  <a href="#struct_handshake" class="auto internal xref">Section 4.3.2</a>.<a href="#section-6.1.6-2.2.3" class="pilcrow">¶</a></p>
<p id="section-6.1.6-2.2.4">The optval type is null.<a href="#section-6.1.6-2.2.4" class="pilcrow">¶</a></p>
</li>
          </ul>
<p id="section-6.1.6-3">The default value in socket is null.<a href="#section-6.1.6-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="sockopt_crypto_secret">
<section id="section-6.1.7">
          <h4 id="name-quic_sockopt_crypto_secret">
<a href="#section-6.1.7" class="section-number selfRef">6.1.7. </a><a href="#name-quic_sockopt_crypto_secret" class="section-name selfRef">QUIC_SOCKOPT_CRYPTO_SECRET</a>
          </h4>
<p id="section-6.1.7-1">This socket option is used to set cryptographic secrets derived from
userspace to the socket in kernel during the QUIC handshake process.<a href="#section-6.1.7-1" class="pilcrow">¶</a></p>
<p id="section-6.1.7-2">The optval type is<a href="#section-6.1.7-2" class="pilcrow">¶</a></p>
<div class="C lang-language sourcecode" id="section-6.1.7-3">
<pre>
struct quic_crypto_secret {
  uint8_t level;
  uint16_t send;
  uint32_t type;
  uint8_t secret[48];
};
</pre><a href="#section-6.1.7-3" class="pilcrow">¶</a>
</div>
<ul class="normal">
<li class="normal" id="section-6.1.7-4.1">
              <p id="section-6.1.7-4.1.1">level: Specifies the QUIC cryptographic level for which the secret
  is intended.<a href="#section-6.1.7-4.1.1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-6.1.7-4.1.2.1">QUIC_CRYPTO_APP: Application level<a href="#section-6.1.7-4.1.2.1" class="pilcrow">¶</a>
</li>
                <li class="normal" id="section-6.1.7-4.1.2.2">QUIC_CRYPTO_HANDSHAKE: Handshake level<a href="#section-6.1.7-4.1.2.2" class="pilcrow">¶</a>
</li>
                <li class="normal" id="section-6.1.7-4.1.2.3">QUIC_CRYPTO_EARLY: Early or 0-RTT level<a href="#section-6.1.7-4.1.2.3" class="pilcrow">¶</a>
</li>
              </ul>
</li>
            <li class="normal" id="section-6.1.7-4.2">
              <p id="section-6.1.7-4.2.1">send: Indicates the direction of the secret.<a href="#section-6.1.7-4.2.1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-6.1.7-4.2.2.1">0: Set secret for receiving<a href="#section-6.1.7-4.2.2.1" class="pilcrow">¶</a>
</li>
                <li class="normal" id="section-6.1.7-4.2.2.2">!0: Set secret for sending<a href="#section-6.1.7-4.2.2.2" class="pilcrow">¶</a>
</li>
              </ul>
</li>
            <li class="normal" id="section-6.1.7-4.3">
              <p id="section-6.1.7-4.3.1">type: Specifies the encryption algorithm used.<a href="#section-6.1.7-4.3.1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-6.1.7-4.3.2.1">AES_GCM_128<a href="#section-6.1.7-4.3.2.1" class="pilcrow">¶</a>
</li>
                <li class="normal" id="section-6.1.7-4.3.2.2">AES_GCM_256<a href="#section-6.1.7-4.3.2.2" class="pilcrow">¶</a>
</li>
                <li class="normal" id="section-6.1.7-4.3.2.3">AES_CCM_128<a href="#section-6.1.7-4.3.2.3" class="pilcrow">¶</a>
</li>
                <li class="normal" id="section-6.1.7-4.3.2.4">CHACHA20_POLY1305<a href="#section-6.1.7-4.3.2.4" class="pilcrow">¶</a>
</li>
              </ul>
</li>
            <li class="normal" id="section-6.1.7-4.4">
              <p id="section-6.1.7-4.4.1">secret: The cryptographic key material to be used. The length of
  this array depends on the type and SHOULD be filled accordingly in
  kernel.<a href="#section-6.1.7-4.4.1" class="pilcrow">¶</a></p>
</li>
          </ul>
<p id="section-6.1.7-5">This option is only relevant during the handshake phase.<a href="#section-6.1.7-5" class="pilcrow">¶</a></p>
</section>
</div>
<div id="sockopt_transport_param_ext">
<section id="section-6.1.8">
          <h4 id="name-quic_sockopt_transport_param">
<a href="#section-6.1.8" class="section-number selfRef">6.1.8. </a><a href="#name-quic_sockopt_transport_param" class="section-name selfRef">QUIC_SOCKOPT_TRANSPORT_PARAM_EXT</a>
          </h4>
<p id="section-6.1.8-1">This socket option is used to retrieve or set the QUIC Transport
Parameters Extension, which is essential for building TLS messages and
handling extended QUIC transport parameters during the handshake
process.<a href="#section-6.1.8-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-6.1.8-2.1">
              <p id="section-6.1.8-2.1.1">Get Operation:<a href="#section-6.1.8-2.1.1" class="pilcrow">¶</a></p>
<p id="section-6.1.8-2.1.2">When retrieving parameters via getsockopt, this option generates the
  QUIC Transport Parameters Extension based on the local transport
  parameters configured in kernel. The retrieved extension helps
  userspace applications build the appropriate TLS messages.<a href="#section-6.1.8-2.1.2" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-6.1.8-2.2">
              <p id="section-6.1.8-2.2.1">Set Operation:<a href="#section-6.1.8-2.2.1" class="pilcrow">¶</a></p>
<p id="section-6.1.8-2.2.2">When setting parameters via setsockopt, this option updates kernel
  with the QUIC Transport Parameters Extension received from the peer's
  TLS message. This ensures that the remote transport parameters are
  correctly configured in the kernel.<a href="#section-6.1.8-2.2.2" class="pilcrow">¶</a></p>
</li>
          </ul>
<div class="C lang-language sourcecode" id="section-6.1.8-3">
<pre>
uint8_t *opt;
</pre><a href="#section-6.1.8-3" class="pilcrow">¶</a>
</div>
<p id="section-6.1.8-4">This option is used exclusively during the handshake phase.<a href="#section-6.1.8-4" class="pilcrow">¶</a></p>
</section>
</div>
</section>
<section id="section-6.2">
        <h3 id="name-read-only-options">
<a href="#section-6.2" class="section-number selfRef">6.2. </a><a href="#name-read-only-options" class="section-name selfRef">Read-Only Options</a>
        </h3>
<div id="sockopt_stream_open">
<section id="section-6.2.1">
          <h4 id="name-quic_sockopt_stream_open">
<a href="#section-6.2.1" class="section-number selfRef">6.2.1. </a><a href="#name-quic_sockopt_stream_open" class="section-name selfRef">QUIC_SOCKOPT_STREAM_OPEN</a>
          </h4>
<p id="section-6.2.1-1">This socket option is used to open a new QUIC stream. It allows
applications to initiate streams for data transmission within a QUIC
connection.<a href="#section-6.2.1-1" class="pilcrow">¶</a></p>
<p id="section-6.2.1-2">The optval type is<a href="#section-6.2.1-2" class="pilcrow">¶</a></p>
<div class="C lang-language sourcecode" id="section-6.2.1-3">
<pre>
struct quic_stream_info {
  uint64_t stream_id;
  uint32_t stream_flags;
};
</pre><a href="#section-6.2.1-3" class="pilcrow">¶</a>
</div>
<ul class="normal">
<li class="normal" id="section-6.2.1-4.1">
              <p id="section-6.2.1-4.1.1">stream_id: Specifies the stream ID for the new stream.
  It can be set to:<a href="#section-6.2.1-4.1.1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-6.2.1-4.1.2.1">&gt;= 0: Open a stream with the specific stream_id provided.<a href="#section-6.2.1-4.1.2.1" class="pilcrow">¶</a>
</li>
                <li class="normal" id="section-6.2.1-4.1.2.2">-1: Open the next available stream. The assigned stream ID will be
  returned to the user via the stream_id field after the operation.<a href="#section-6.2.1-4.1.2.2" class="pilcrow">¶</a>
</li>
              </ul>
</li>
            <li class="normal" id="section-6.2.1-4.2">
              <p id="section-6.2.1-4.2.1">stream_flags: Specifies flags for stream creation.
  It can be set to:<a href="#section-6.2.1-4.2.1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-6.2.1-4.2.2.1">QUIC_STREAM_UNI: Open the next unidirectional stream.<a href="#section-6.2.1-4.2.2.1" class="pilcrow">¶</a>
</li>
                <li class="normal" id="section-6.2.1-4.2.2.2">QUIC_STREAM_DONTWAIT: Open the stream without blocking; this allows
  the request to be processed asynchronously.<a href="#section-6.2.1-4.2.2.2" class="pilcrow">¶</a>
</li>
              </ul>
</li>
          </ul>
</section>
</div>
</section>
<section id="section-6.3">
        <h3 id="name-write-only-options">
<a href="#section-6.3" class="section-number selfRef">6.3. </a><a href="#name-write-only-options" class="section-name selfRef">Write-Only Options</a>
        </h3>
<div id="sockopt_stream_reset">
<section id="section-6.3.1">
          <h4 id="name-quic_sockopt_stream_reset">
<a href="#section-6.3.1" class="section-number selfRef">6.3.1. </a><a href="#name-quic_sockopt_stream_reset" class="section-name selfRef">QUIC_SOCKOPT_STREAM_RESET</a>
          </h4>
<p id="section-6.3.1-1">This socket option is used to reset a specific QUIC stream. Resetting a
stream indicates that the endpoint will no longer guarantee the delivery
of data associated with that stream.<a href="#section-6.3.1-1" class="pilcrow">¶</a></p>
<p id="section-6.3.1-2">The optval type is<a href="#section-6.3.1-2" class="pilcrow">¶</a></p>
<div class="C lang-language sourcecode" id="section-6.3.1-3">
<pre>
struct quic_errinfo {
  uint64_t stream_id;
  uint32_t errcode;
};
</pre><a href="#section-6.3.1-3" class="pilcrow">¶</a>
</div>
<ul class="normal">
<li class="normal" id="section-6.3.1-4.1">stream_id: Specifies the ID of the stream to be reset.<a href="#section-6.3.1-4.1" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-6.3.1-4.2">errcode: An application protocol error code indicating the reason for
the stream reset.<a href="#section-6.3.1-4.2" class="pilcrow">¶</a>
</li>
          </ul>
</section>
</div>
<div id="sockopt_stream_stop_sending">
<section id="section-6.3.2">
          <h4 id="name-quic_sockopt_stream_stop_se">
<a href="#section-6.3.2" class="section-number selfRef">6.3.2. </a><a href="#name-quic_sockopt_stream_stop_se" class="section-name selfRef">QUIC_SOCKOPT_STREAM_STOP_SENDING</a>
          </h4>
<p id="section-6.3.2-1">This socket option is used to request that the peer stop sending data
on a specified QUIC stream. This is typically used to signal that the
local endpoint is no longer interested in receiving further data on that
stream.<a href="#section-6.3.2-1" class="pilcrow">¶</a></p>
<p id="section-6.3.2-2">The optval type is<a href="#section-6.3.2-2" class="pilcrow">¶</a></p>
<div class="C lang-language sourcecode" id="section-6.3.2-3">
<pre>
struct quic_errinfo {
  uint64_t stream_id;
  uint32_t errcode;
};
</pre><a href="#section-6.3.2-3" class="pilcrow">¶</a>
</div>
<ul class="normal">
<li class="normal" id="section-6.3.2-4.1">stream_id: Specifies the ID of the stream to be reset.<a href="#section-6.3.2-4.1" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-6.3.2-4.2">errcode: An application protocol error code indicating the reason for
the stream stop_sending.<a href="#section-6.3.2-4.2" class="pilcrow">¶</a>
</li>
          </ul>
</section>
</div>
<div id="sockopt_migration">
<section id="section-6.3.3">
          <h4 id="name-quic_sockopt_connection_mig">
<a href="#section-6.3.3" class="section-number selfRef">6.3.3. </a><a href="#name-quic_sockopt_connection_mig" class="section-name selfRef">QUIC_SOCKOPT_CONNECTION_MIGRATION</a>
          </h4>
<p id="section-6.3.3-1">This socket option is used to initiate a connection migration, which
allows the QUIC connection to switch to a new address. It can also be
used on the server side to set the preferred address transport parameter
before the handshake.<a href="#section-6.3.3-1" class="pilcrow">¶</a></p>
<p id="section-6.3.3-2">The optval type is<a href="#section-6.3.3-2" class="pilcrow">¶</a></p>
<div class="C lang-language sourcecode" id="section-6.3.3-3">
<pre>
struct sockaddr_in(6);
</pre><a href="#section-6.3.3-3" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="sockopt_key_update">
<section id="section-6.3.4">
          <h4 id="name-quic_sockopt_key_update">
<a href="#section-6.3.4" class="section-number selfRef">6.3.4. </a><a href="#name-quic_sockopt_key_update" class="section-name selfRef">QUIC_SOCKOPT_KEY_UPDATE</a>
          </h4>
<p id="section-6.3.4-1">This socket option is used to initiate a key update or rekeying process
for the QUIC connection.<a href="#section-6.3.4-1" class="pilcrow">¶</a></p>
<p id="section-6.3.4-2">The optval type is null.<a href="#section-6.3.4-2" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</section>
</div>
<section id="section-7">
      <h2 id="name-handshake-interface-for-ker">
<a href="#section-7" class="section-number selfRef">7. </a><a href="#name-handshake-interface-for-ker" class="section-name selfRef">Handshake Interface for Kernel Consumers</a>
      </h2>
<p id="section-7-1">In-kernel QUIC is not only beneficial for userspace applications such
as HTTP/3, but it also naturally supports kernel consumers like SMB and
NFS. For these kernel consumers, a userspace service is needed to handle
handshake requests from kernel. The communication between userspace
and kernel can vary across different operating systems. Generally, there
are two methods to handle this interaction:<a href="#section-7-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7-2.1">
          <p id="section-7-2.1.1">Attaching and Sending Socket Descriptors:<a href="#section-7-2.1.1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7-2.1.2.1">Kernel consumers attach a socket file descriptor (sockfd) to a
  connecting or accepting kernel socket.<a href="#section-7-2.1.2.1" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-7-2.1.2.2">This sockfd is then sent to userspace, where the userspace service
  performs the handshake as if it were handling a userspace socket.<a href="#section-7-2.1.2.2" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-7-2.1.2.3">Once the handshake is complete, the service sends the sockfd back to
  kernel. Kernel then detaches the sockfd from kernel socket, which is
  now in an established state.<a href="#section-7-2.1.2.3" class="pilcrow">¶</a>
</li>
          </ul>
</li>
        <li class="normal" id="section-7-2.2">
          <p id="section-7-2.2.1">Sending Raw TLS Messages with an session ID:<a href="#section-7-2.2.1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7-2.2.2.1">Kernel consumers send raw TLS messages to userspace, identified by
  an session ID.<a href="#section-7-2.2.2.1" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-7-2.2.2.2">The userspace service creates a TLS session associated with this ID
  and exchanges TLS messages with the session.<a href="#section-7-2.2.2.2" class="pilcrow">¶</a>
</li>
            <li class="normal" id="section-7-2.2.2.3">The service then sends the response TLS messages back to kernel. This
  method requires maintaining the TLS session identified by the ID in
  userspace until the handshake is complete after multiple exchanges.<a href="#section-7-2.2.2.3" class="pilcrow">¶</a>
</li>
          </ul>
</li>
      </ul>
<p id="section-7-3">On Linux, the tlshd service utilizes the first method via Netlink.<a href="#section-7-3" class="pilcrow">¶</a></p>
<p id="section-7-4">For further details on the infrastructure design in Linux, refer to
<a href="#example_kernel" class="auto internal xref">Appendix C</a><a href="#section-7-4" class="pilcrow">¶</a></p>
</section>
<section id="section-8">
      <h2 id="name-iana-considerations">
<a href="#section-8" class="section-number selfRef">8. </a><a href="#name-iana-considerations" class="section-name selfRef">IANA Considerations</a>
      </h2>
<p id="section-8-1">No actions from IANA required.<a href="#section-8-1" class="pilcrow">¶</a></p>
</section>
<section id="section-9">
      <h2 id="name-security-considerations">
<a href="#section-9" class="section-number selfRef">9. </a><a href="#name-security-considerations" class="section-name selfRef">Security Considerations</a>
      </h2>
<p id="section-9-1">The socket receive buffer SHOULD be adjusted according to the max_data
parameter from the struct quic_transport_param. The implementation SHOULD
update the socket receive buffer whenever the local transport parameter
max_data changes. Using a socket receive buffer smaller than the local
transport parameter max_data MAY impair performance.<a href="#section-9-1" class="pilcrow">¶</a></p>
<p id="section-9-2">Similarly, the socket send buffer SHOULD be adjusted based on the peer's
max_data transport parameter to optimize performance, rather than setting
it manually.<a href="#section-9-2" class="pilcrow">¶</a></p>
<p id="section-9-3">Additionally, the size of the optval for the following socket options
SHOULD be limited to avoid excessive memory allocation:<a href="#section-9-3" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-9-4.1">QUIC_SOCKOPT_ALPN<a href="#section-9-4.1" class="pilcrow">¶</a>
</li>
        <li class="normal" id="section-9-4.2">QUIC_SOCKOPT_TOKEN<a href="#section-9-4.2" class="pilcrow">¶</a>
</li>
        <li class="normal" id="section-9-4.3">QUIC_SOCKOPT_SESSION_TICKET<a href="#section-9-4.3" class="pilcrow">¶</a>
</li>
        <li class="normal" id="section-9-4.4">QUIC_SOCKOPT_CONNECTION_CLOSE<a href="#section-9-4.4" class="pilcrow">¶</a>
</li>
      </ul>
</section>
<section id="section-10">
      <h2 id="name-references">
<a href="#section-10" class="section-number selfRef">10. </a><a href="#name-references" class="section-name selfRef">References</a>
      </h2>
<section id="section-10.1">
        <h3 id="name-normative-references">
<a href="#section-10.1" class="section-number selfRef">10.1. </a><a href="#name-normative-references" class="section-name selfRef">Normative References</a>
        </h3>
<dl class="references">
<dt id="RFC0768">[RFC0768]</dt>
        <dd>
<span class="refAuthor">Postel, J.</span>, <span class="refTitle">"User Datagram Protocol"</span>, <span class="seriesInfo">STD 6</span>, <span class="seriesInfo">RFC 768</span>, <span class="seriesInfo">DOI 10.17487/RFC0768</span>, <time datetime="1980-08" class="refDate">August 1980</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc768">https://www.rfc-editor.org/info/rfc768</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC9000">[RFC9000]</dt>
        <dd>
<span class="refAuthor">Iyengar, J., Ed.</span> and <span class="refAuthor">M. Thomson, Ed.</span>, <span class="refTitle">"QUIC: A UDP-Based Multiplexed and Secure Transport"</span>, <span class="seriesInfo">RFC 9000</span>, <span class="seriesInfo">DOI 10.17487/RFC9000</span>, <time datetime="2021-05" class="refDate">May 2021</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc9000">https://www.rfc-editor.org/info/rfc9000</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC9293">[RFC9293]</dt>
      <dd>
<span class="refAuthor">Eddy, W., Ed.</span>, <span class="refTitle">"Transmission Control Protocol (TCP)"</span>, <span class="seriesInfo">STD 7</span>, <span class="seriesInfo">RFC 9293</span>, <span class="seriesInfo">DOI 10.17487/RFC9293</span>, <time datetime="2022-08" class="refDate">August 2022</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc9293">https://www.rfc-editor.org/info/rfc9293</a>&gt;</span>. </dd>
<dd class="break"></dd>
</dl>
</section>
<section id="section-10.2">
        <h3 id="name-informative-references">
<a href="#section-10.2" class="section-number selfRef">10.2. </a><a href="#name-informative-references" class="section-name selfRef">Informative References</a>
        </h3>
<dl class="references">
<dt id="RFC2119">[RFC2119]</dt>
        <dd>
<span class="refAuthor">Bradner, S.</span>, <span class="refTitle">"Key words for use in RFCs to Indicate Requirement Levels"</span>, <span class="seriesInfo">BCP 14</span>, <span class="seriesInfo">RFC 2119</span>, <span class="seriesInfo">DOI 10.17487/RFC2119</span>, <time datetime="1997-03" class="refDate">March 1997</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc2119">https://www.rfc-editor.org/info/rfc2119</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC3542">[RFC3542]</dt>
        <dd>
<span class="refAuthor">Stevens, W.</span>, <span class="refAuthor">Thomas, M.</span>, <span class="refAuthor">Nordmark, E.</span>, and <span class="refAuthor">T. Jinmei</span>, <span class="refTitle">"Advanced Sockets Application Program Interface (API) for IPv6"</span>, <span class="seriesInfo">RFC 3542</span>, <span class="seriesInfo">DOI 10.17487/RFC3542</span>, <time datetime="2003-05" class="refDate">May 2003</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc3542">https://www.rfc-editor.org/info/rfc3542</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC3493">[RFC3493]</dt>
        <dd>
<span class="refAuthor">Gilligan, R.</span>, <span class="refAuthor">Thomson, S.</span>, <span class="refAuthor">Bound, J.</span>, <span class="refAuthor">McCann, J.</span>, and <span class="refAuthor">W. Stevens</span>, <span class="refTitle">"Basic Socket Interface Extensions for IPv6"</span>, <span class="seriesInfo">RFC 3493</span>, <span class="seriesInfo">DOI 10.17487/RFC3493</span>, <time datetime="2003-02" class="refDate">February 2003</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc3493">https://www.rfc-editor.org/info/rfc3493</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC6458">[RFC6458]</dt>
      <dd>
<span class="refAuthor">Stewart, R.</span>, <span class="refAuthor">Tuexen, M.</span>, <span class="refAuthor">Poon, K.</span>, <span class="refAuthor">Lei, P.</span>, and <span class="refAuthor">V. Yasevich</span>, <span class="refTitle">"Sockets API Extensions for the Stream Control Transmission Protocol (SCTP)"</span>, <span class="seriesInfo">RFC 6458</span>, <span class="seriesInfo">DOI 10.17487/RFC6458</span>, <time datetime="2011-12" class="refDate">December 2011</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc6458">https://www.rfc-editor.org/info/rfc6458</a>&gt;</span>. </dd>
<dd class="break"></dd>
</dl>
</section>
</section>
<div id="example_stream">
<section id="appendix-A">
      <h2 id="name-example-for-multi-streaming">
<a href="#appendix-A" class="section-number selfRef">Appendix A. </a><a href="#name-example-for-multi-streaming" class="section-name selfRef">Example For Multi-streaming Usage</a>
      </h2>
<p id="appendix-A-1">This example demonstrates how to use quic_sendmsg() and quic_recvmsg()
to send and receive messages across multiple QUIC streams
simultaneously.<a href="#appendix-A-1" class="pilcrow">¶</a></p>
<div class="C breakable lang-language sourcecode" id="appendix-A-2">
<pre>
#include &lt;sys/socket.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;

#include &lt;netinet/quic.h&gt;

struct stream {
    char msg[50];
    uint32_t len;
    uint32_t flags;
};

static int do_client(int argc, char *argv[])
{
    struct stream stream[2] = {};
    struct sockaddr_in ra = {};
    int ret, sockfd;
    uint32_t flags;
    uint64_t sid;
    char msg[50];

    if (argc &lt; 3) {
        printf("%s client &lt;PEER ADDR&gt; &lt;PEER PORT&gt;\n", argv[0]);
        return 0;
    }

    sockfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_QUIC);
    if (sockfd &lt; 0) {
        printf("socket create failed\n");
        return -1;
    }

    ra.sin_family = AF_INET;
    ra.sin_port = htons(atoi(argv[3]));
    inet_pton(AF_INET, argv[2], &amp;ra.sin_addr.s_addr);

    if (connect(sockfd, (struct sockaddr *)&amp;ra, sizeof(ra))) {
        printf("socket connect failed\n");
        return -1;
    }

    if (quic_client_handshake(sockfd, NULL, NULL))
        return -1;

    /* Open stream 0 and send first data on stream 0 */
    strcpy(msg, "hello ");
    sid = 0;
    flags = MSG_STREAM_NEW;
    ret = quic_sendmsg(sockfd, msg, strlen(msg), sid, flags);
    if (ret == -1) {
        printf("send error %d %d\n", ret, errno);
        return -1;
    }
    stream[sid &gt;&gt; 1].len += ret;

    /* Open stream 2 and send first data on stream 2 */
    strcpy(msg, "hello quic ");
    sid = 2;
    flags = MSG_STREAM_NEW;
    ret = quic_sendmsg(sockfd, msg, strlen(msg), sid, flags);
    if (ret == -1) {
        printf("send error %d %d\n", ret, errno);
        return -1;
    }
    stream[sid &gt;&gt; 1].len += ret;

    /* Send second data on stream 0 */
    strcpy(msg, "quic ");
    sid = 0;
    flags = 0;
    ret = quic_sendmsg(sockfd, msg, strlen(msg), sid, flags);
    if (ret == -1) {
        printf("send error %d %d\n", ret, errno);
        return -1;
    }
    stream[sid &gt;&gt; 1].len += ret;

    /* Send second (last) data on stream 2 */
    strcpy(msg, "server stream 2!");
    sid = 2;
    flags = MSG_STREAM_FIN;
    ret = quic_sendmsg(sockfd, msg, strlen(msg), sid, flags);
    if (ret == -1) {
        printf("send error %d %d\n", ret, errno);
        return -1;
    }
    stream[sid &gt;&gt; 1].len += ret;

    /* Send third (last) data on stream 0 */
    strcpy(msg, "server stream 0!");
    sid = 0;
    flags = MSG_STREAM_FIN;
    ret = quic_sendmsg(sockfd, msg, strlen(msg), sid, flags);
    if (ret == -1) {
        printf("send error %d %d\n", ret, errno);
        return -1;
    }
    stream[sid &gt;&gt; 1].len += ret;
    sid = 0;
    printf("send %d, len: %u, sid: %lu\n", ret,
           stream[sid &gt;&gt; 1].len, sid);
    sid = 2;
    printf("send %d, len: %u, sid: %lu\n", ret,
           stream[sid &gt;&gt; 1].len, sid);

    memset(msg, 0, sizeof(msg));
    ret = quic_recvmsg(sockfd, msg, sizeof(msg), &amp;sid, &amp;flags);
    if (ret == -1) {
        printf("recv error %d %d\n", ret, errno);
        return 1;
    }
    printf("recv: \"%s\", len: %d, sid: %lu\n", msg, ret, sid);

    close(sockfd);
    return 0;
}

static int do_server(int argc, char *argv[])
{
    struct stream stream[2] = {};
    struct sockaddr_in sa = {};
    int listenfd, sockfd, ret;
    unsigned int addrlen;
    uint32_t flags;
    uint64_t sid;
    char msg[50];

    if (argc &lt; 5) {
        printf("%s server &lt;LOCAL ADDR&gt; &lt;LOCAL PORT&gt;"
               "&lt;PRIVATE_KEY_FILE&gt; &lt;CERTIFICATE_FILE&gt;\n", argv[0]);
        return 0;
    }

    sa.sin_family = AF_INET;
    sa.sin_port = htons(atoi(argv[3]));
    inet_pton(AF_INET, argv[2], &amp;sa.sin_addr.s_addr);
    listenfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_QUIC);
    if (listenfd &lt; 0) {
        printf("socket create failed\n");
        return -1;
    }
    if (bind(listenfd, (struct sockaddr *)&amp;sa, sizeof(sa))) {
        printf("socket bind failed\n");
        return -1;
    }
    if (listen(listenfd, 1)) {
        printf("socket listen failed\n");
        return -1;
    }
    addrlen = sizeof(sa);
    sockfd = accept(listenfd, (struct sockaddr *)&amp;sa, &amp;addrlen);
    if (sockfd &lt; 0) {
        printf("socket accept failed %d %d\n", errno, sockfd);
        return -1;
    }

    if (quic_server_handshake(sockfd, argv[4], argv[5]))
        return -1;

    while (!(stream[0].flags &amp; MSG_STREAM_FIN) ||
           !(stream[1].flags &amp; MSG_STREAM_FIN)) {
        ret = quic_recvmsg(sockfd, msg, sizeof(msg), &amp;sid, &amp;flags);
        if (ret == -1) {
            printf("recv error %d %d\n", ret, errno);
            return 1;
        }
        sid &gt;&gt;= 1;
        memcpy(stream[sid].msg + stream[sid].len, msg, ret);
        stream[sid].len += ret;
        stream[sid].flags = flags;
    }
    sid = 0;
    printf("recv: \"%s\", len: %d, sid: %lu\n",
           stream[sid &gt;&gt; 1].msg, stream[sid &gt;&gt; 1].len, sid);
    sid = 2;
    printf("recv: \"%s\", len: %d, sid: %lu\n",
           stream[sid &gt;&gt; 1].msg, stream[sid &gt;&gt; 1].len, sid);

    strcpy(msg, "hello quic client stream 1!");
    sid = 1;
    flags = MSG_STREAM_NEW | MSG_STREAM_FIN;
    ret = quic_sendmsg(sockfd, msg, strlen(msg), sid, flags);
    if (ret == -1) {
        printf("send error %d %d\n", ret, errno);
        return -1;
    }
    printf("send %d, sid: %lu\n", ret, sid);

    close(sockfd);
    close(listenfd);
    return 0;
}

int main(int argc, char *argv[])
{
    if (argc &lt; 2 || (strcmp(argv[1], "server") &amp;&amp;
        strcmp(argv[1], "client"))) {
        printf("%s server|client ...\n", argv[0]);
        return 0;
    }

    if (!strcmp(argv[1], "client"))
        return do_client(argc, argv);

    return do_server(argc, argv);
}
</pre><a href="#appendix-A-2" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="example_early">
<section id="appendix-B">
      <h2 id="name-example-for-session-consump">
<a href="#appendix-B" class="section-number selfRef">Appendix B. </a><a href="#name-example-for-session-consump" class="section-name selfRef">Example For Session Consumption and 0-RTT transmission</a>
      </h2>
<p id="appendix-B-1">This example illustrates how to use the socket options TOKEN,
SESSION_TICKET, and TRANSPORT_PARAM to achieve session resumption
and 0-RTT data transmission with QUIC.<a href="#appendix-B-1" class="pilcrow">¶</a></p>
<div class="C breakable lang-language sourcecode" id="appendix-B-2">
<pre>
#include &lt;sys/socket.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;

#include &lt;netinet/quic.h&gt;

static uint8_t ticket[4096];
static uint8_t token[256];

static int do_client(int argc, char *argv[])
{
    unsigned int ticket_len, param_len, token_len, addr_len;
    struct quic_transport_param param = {};
    struct sockaddr_in ra = {}, la = {};
    int ret, sockfd;
    char msg[50];

    if (argc &lt; 3) {
        printf("%s client &lt;PEER ADDR&gt; &lt;PEER PORT&gt;\n", argv[0]);
        return 0;
    }

    sockfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_QUIC);
    if (sockfd &lt; 0) {
        printf("socket create failed\n");
        return -1;
    }

    ra.sin_family = AF_INET;
    ra.sin_port = htons(atoi(argv[3]));
    inet_pton(AF_INET, argv[2], &amp;ra.sin_addr.s_addr);

    if (connect(sockfd, (struct sockaddr *)&amp;ra, sizeof(ra))) {
        printf("socket connect failed\n");
        return -1;
    }

    param.receive_session_ticket = 1;
    param_len = sizeof(param);
    ret = setsockopt(sockfd, SOL_QUIC, QUIC_SOCKOPT_TRANSPORT_PARAM,
                     &amp;param, param_len);
    if (ret == -1)
        return -1;

    if (quic_client_handshake(sockfd, NULL, NULL))
        return -1;

    /* get ticket and param after handshake (you can save
     * it somewhere).
     */
    ticket_len = sizeof(ticket);
    ret = getsockopt(sockfd, SOL_QUIC, QUIC_SOCKOPT_SESSION_TICKET,
                     ticket, &amp;ticket_len);
    if (ret == -1 || !ticket_len) {
        printf("socket getsockopt session ticket\n");
        return -1;
    }

    param_len = sizeof(param);
    param.remote = 1;
    ret = getsockopt(sockfd, SOL_QUIC, QUIC_SOCKOPT_TRANSPORT_PARAM,
                     &amp;param, &amp;param_len);
    if (ret == -1) {
        printf("socket getsockopt remote transport param\n");
        return -1;
    }

    /* get token and local address (needed when peer
     * validate_address is set).
     */
    token_len = sizeof(token);
    ret = getsockopt(sockfd, SOL_QUIC, QUIC_SOCKOPT_TOKEN, &amp;token,
                     &amp;token_len);
    if (ret == -1) {
        printf("socket getsockopt regular token\n");
        return -1;
    }

    addr_len = sizeof(la);
    ret = getsockname(sockfd, (struct sockaddr *)&amp;la, &amp;addr_len);
    if (ret == -1) {
        printf("getsockname local address and port used\n");
        return -1;
    }

    printf("get the session ticket %d and transport param %d and"
           "token %d, save it\n", ticket_len, param_len, token_len);

    strcpy(msg, "hello quic server!");
    ret = send(sockfd, msg, strlen(msg), MSG_SYN | MSG_FIN);
    if (ret == -1) {
        printf("send error %d %d\n", ret, errno);
        return -1;
    }
    printf("send %d\n", ret);

    memset(msg, 0, sizeof(msg));
    ret = recv(sockfd, msg, sizeof(msg), 0);
    if (ret == -1) {
        printf("recv error %d %d\n", ret, errno);
        return 1;
    }
    printf("recv: \"%s\", len: %d\n", msg, ret);

    close(sockfd);

    printf("start new connection with the session ticket used...\n");
    sleep(2);

    sockfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_QUIC);
    if (sockfd &lt; 0) {
        printf("socket create failed\n");
        return -1;
    }

    /* bind previous address and port and set token for
     * address validation.
     */
    if (bind(sockfd, (struct sockaddr *)&amp;la, addr_len)) {
        printf("socket bind failed\n");
        return -1;
    }
    ret = setsockopt(sockfd, SOL_QUIC, QUIC_SOCKOPT_TOKEN, token,
                     token_len);
    if (ret == -1) {
        printf("socket setsockopt token\n");
        return -1;
    }

    ra.sin_family = AF_INET;
    ra.sin_port = htons(atoi(argv[3]));
    inet_pton(AF_INET, argv[2], &amp;ra.sin_addr.s_addr);

    if (connect(sockfd, (struct sockaddr *)&amp;ra, sizeof(ra))) {
        printf("socket connect failed\n");
        return -1;
    }

    /* set the ticket and remote param and early data into
     * the socket for handshake.
     */
    ret = setsockopt(sockfd, SOL_QUIC, QUIC_SOCKOPT_SESSION_TICKET,
                     ticket, ticket_len);
    if (ret == -1) {
        printf("socket setsockopt session ticket\n");
        return -1;
    }
    ret = setsockopt(sockfd, SOL_QUIC, QUIC_SOCKOPT_TRANSPORT_PARAM,
                     &amp;param, param_len);
    if (ret == -1) {
        printf("socket setsockopt remote transport param\n");
        return -1;
    }
    strcpy(msg, "hello quic server, I'm back!");
    ret = send(sockfd, msg, strlen(msg), MSG_SYN | MSG_FIN);
    if (ret == -1) {
        printf("send error %d %d\n", ret, errno);
        return -1;
    }
    printf("send %d\n", ret);

    if (quic_client_handshake(sockfd, NULL, NULL))
        return -1;

    memset(msg, 0, sizeof(msg));
    ret = recv(sockfd, msg, sizeof(msg), 0);
    if (ret == -1) {
        printf("recv error %d %d\n", ret, errno);
        return 1;
    }
    printf("recv: \"%s\", len: %d\n", msg, ret);

    close(sockfd);
    return 0;
}

static int do_server(int argc, char *argv[])
{
    struct quic_transport_param param = {};
    struct sockaddr_in sa = {};
    int listenfd, sockfd, ret;
    unsigned int addrlen;
    char msg[50];

    if (argc &lt; 5) {
        printf("%s server &lt;LOCAL ADDR&gt; &lt;LOCAL PORT&gt;"
               "&lt;PRIVATE_KEY_FILE&gt; &lt;CERTIFICATE_FILE&gt;\n", argv[0]);
        return 0;
    }

    sa.sin_family = AF_INET;
    sa.sin_port = htons(atoi(argv[3]));
    inet_pton(AF_INET, argv[2], &amp;sa.sin_addr.s_addr);
    listenfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_QUIC);
    if (listenfd &lt; 0) {
        printf("socket create failed\n");
        return -1;
    }
    if (bind(listenfd, (struct sockaddr *)&amp;sa, sizeof(sa))) {
        printf("socket bind failed\n");
        return -1;
    }
    if (listen(listenfd, 1)) {
        printf("socket listen failed\n");
        return -1;
    }
    param.validate_peer_address = 1;
    if (setsockopt(listenfd, SOL_QUIC, QUIC_SOCKOPT_TRANSPORT_PARAM,
                   &amp;param, sizeof(param)))
        return -1;
    addrlen = sizeof(sa);
    sockfd = accept(listenfd, (struct sockaddr *)&amp;sa, &amp;addrlen);
    if (sockfd &lt; 0) {
        printf("socket accept failed %d %d\n", errno, sockfd);
        return -1;
    }

    if (quic_server_handshake(sockfd, argv[4], argv[5]))
        return -1;

    memset(msg, 0, sizeof(msg));
    ret = recv(sockfd, msg, sizeof(msg), 0);
    if (ret == -1) {
        printf("recv error %d %d\n", ret, errno);
        return 1;
    }
    printf("recv: \"%s\", len: %d\n", msg, ret);

    strcpy(msg, "hello quic client!");
    ret = send(sockfd, msg, strlen(msg), MSG_SYN | MSG_FIN);
    if (ret == -1) {
        printf("send error %d %d\n", ret, errno);
        return -1;
    }
    printf("send %d\n", ret);

    close(sockfd);

    printf("wait for the client next connection...\n");

    addrlen = sizeof(sa);
    sockfd = accept(listenfd, (struct sockaddr *)&amp;sa, &amp;addrlen);
    if (sockfd &lt; 0) {
        printf("socket accept failed %d %d\n", errno, sockfd);
        return -1;
    }

    if (quic_server_handshake(sockfd, argv[4], argv[5]))
        return -1;

    memset(msg, 0, sizeof(msg));
    ret = recv(sockfd, msg, sizeof(msg), 0);
    if (ret == -1) {
        printf("recv error %d %d\n", ret, errno);
        return 1;
    }
    printf("recv: \"%s\", len: %d\n", msg, ret);

    strcpy(msg, "hello quic client! welcome back!");
    ret = send(sockfd, msg, strlen(msg), MSG_SYN | MSG_FIN);
    if (ret == -1) {
        printf("send error %d %d\n", ret, errno);
        return -1;
    }
    printf("send %d\n", ret);

    close(sockfd);
    close(listenfd);
    return 0;
}

int main(int argc, char *argv[])
{
    if (argc &lt; 2 || (strcmp(argv[1], "server") &amp;&amp;
        strcmp(argv[1], "client"))) {
        printf("%s server|client ...\n", argv[0]);
        return 0;
    }

    if (!strcmp(argv[1], "client"))
        return do_client(argc, argv);

    return do_server(argc, argv);
}
</pre><a href="#appendix-B-2" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="example_kernel">
<section id="appendix-C">
      <h2 id="name-example-for-kernel-consumer">
<a href="#appendix-C" class="section-number selfRef">Appendix C. </a><a href="#name-example-for-kernel-consumer" class="section-name selfRef">Example For Kernel Consumers Architecture Design</a>
      </h2>
<p id="appendix-C-1">In-kernel QUIC facilitates integration with kernel consumers. Below is
the design architecture for handling QUIC handshakes in Linux kernel:<a href="#appendix-C-1" class="pilcrow">¶</a></p>
<div class="C lang-language sourcecode" id="appendix-C-2">
<pre>
┌──────┐  ┌──────┐
│ APP1 │  │ APP2 │ ...
└──────┘  └──────┘
┌──────────────────────────────────────────┐
│     {quic_client/server_handshake()}     │&lt;─────────────┐
└──────────────────────────────────────────┘       ┌─────────────┐
 {send/recvmsg()}      {set/getsockopt()}          │    tlshd    │
 [CMSG handshake_info] [SOCKOPT_CRYPTO_SECRET]     └─────────────┘
                       [SOCKOPT_TRANSPORT_PARAM_EXT]    │   ^
              │ ^                  │ ^                  │   │
Userspace     │ │                  │ │                  │   │
──────────────│─│──────────────────│─│──────────────────│───│────────
Kernel        │ │                  │ │                  │   │
              v │                  v │                  v   │
┌──────────────────────────────────────────┐       ┌─────────────┐
│ socket (IPPROTO_QUIC) |     protocol     │&lt;──┐   │ handshake   │
├──────────────────────────────────────────┤   │   │netlink APIs │
│ stream | connid | cong  | path  | timer  │   │   └─────────────┘
├──────────────────────────────────────────┤   │      │       │
│  packet  |  frame  |  crypto  |  pnmap   │   │   ┌─────┐ ┌─────┐
├──────────────────────────────────────────┤   │   │     │ │     │
│        input       |       output        │   │───│ SMB │ │ NFS │...
├──────────────────────────────────────────┤   │   │     │ │     │
│                UDP tunnels               │   │   └─────┘ └─────┘
└──────────────────────────────────────────┘   └──────┴───────┘
</pre><a href="#appendix-C-2" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="authors-addresses">
<section id="appendix-D">
      <h2 id="name-authors-address">
<a href="#name-authors-address" class="section-name selfRef">Author's Address</a>
      </h2>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Xin Long (<span class="role">editor</span>)</span></div>
<div dir="auto" class="left"><span class="org">Red Hat</span></div>
<div dir="auto" class="left"><span class="street-address">20 Deerfield Drive</span></div>
<div dir="auto" class="left">
<span class="locality">Ottawa</span> <span class="region">ON</span> </div>
<div dir="auto" class="left"><span class="country-name">Canada</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:lucien.xin@gmail.com" class="email">lucien.xin@gmail.com</a>
</div>
</address>
</section>
</div>
<script>const toc = document.getElementById("toc");
toc.querySelector("h2").addEventListener("click", e => {
  toc.classList.toggle("active");
});
toc.querySelector("nav").addEventListener("click", e => {
  toc.classList.remove("active");
});
</script>
</body>
</html>
